{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\nvar _excluded = [\"mods\"];\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  getConfig: true,\n  getPackageJson: true,\n  readConfigJson: true,\n  getConfigFilePaths: true,\n  findConfigFile: true,\n  configFilename: true,\n  readExpRcAsync: true,\n  resetCustomConfigPaths: true,\n  setCustomConfigPath: true,\n  modifyConfigAsync: true,\n  writeConfigJsonAsync: true,\n  getWebOutputPath: true,\n  getNameFromConfig: true,\n  getDefaultTarget: true,\n  getProjectConfigDescription: true,\n  getProjectConfigDescriptionWithPaths: true,\n  isLegacyImportsEnabled: true\n};\nexports.configFilename = configFilename;\nexports.findConfigFile = findConfigFile;\nexports.getConfig = getConfig;\nexports.getConfigFilePaths = getConfigFilePaths;\nexports.getDefaultTarget = getDefaultTarget;\nexports.getNameFromConfig = getNameFromConfig;\nexports.getPackageJson = getPackageJson;\nexports.getProjectConfigDescription = getProjectConfigDescription;\nexports.getProjectConfigDescriptionWithPaths = getProjectConfigDescriptionWithPaths;\nexports.getWebOutputPath = getWebOutputPath;\nObject.defineProperty(exports, \"isLegacyImportsEnabled\", {\n  enumerable: true,\n  get: function get() {\n    return _isLegacyImportsEnabled().isLegacyImportsEnabled;\n  }\n});\nexports.modifyConfigAsync = modifyConfigAsync;\nexports.readConfigJson = readConfigJson;\nexports.readExpRcAsync = readExpRcAsync;\nexports.resetCustomConfigPaths = resetCustomConfigPaths;\nexports.setCustomConfigPath = setCustomConfigPath;\nexports.writeConfigJsonAsync = writeConfigJsonAsync;\nfunction _jsonFile() {\n  var data = _interopRequireDefault(require(\"@expo/json-file\"));\n  _jsonFile = function _jsonFile() {\n    return data;\n  };\n  return data;\n}\nfunction _fs() {\n  var data = _interopRequireDefault(require(\"fs\"));\n  _fs = function _fs() {\n    return data;\n  };\n  return data;\n}\nfunction _glob() {\n  var data = require(\"glob\");\n  _glob = function _glob() {\n    return data;\n  };\n  return data;\n}\nfunction _path() {\n  var data = _interopRequireDefault(require(\"path\"));\n  _path = function _path() {\n    return data;\n  };\n  return data;\n}\nfunction _resolveFrom() {\n  var data = _interopRequireDefault(require(\"resolve-from\"));\n  _resolveFrom = function _resolveFrom() {\n    return data;\n  };\n  return data;\n}\nfunction _semver() {\n  var data = _interopRequireDefault(require(\"semver\"));\n  _semver = function _semver() {\n    return data;\n  };\n  return data;\n}\nfunction _slugify() {\n  var data = _interopRequireDefault(require(\"slugify\"));\n  _slugify = function _slugify() {\n    return data;\n  };\n  return data;\n}\nfunction _Errors() {\n  var data = require(\"./Errors\");\n  _Errors = function _Errors() {\n    return data;\n  };\n  return data;\n}\nfunction _Project() {\n  var data = require(\"./Project\");\n  _Project = function _Project() {\n    return data;\n  };\n  return data;\n}\nfunction _getConfig() {\n  var data = require(\"./getConfig\");\n  _getConfig = function _getConfig() {\n    return data;\n  };\n  return data;\n}\nfunction _getFullName() {\n  var data = require(\"./getFullName\");\n  _getFullName = function _getFullName() {\n    return data;\n  };\n  return data;\n}\nfunction _withConfigPlugins() {\n  var data = require(\"./plugins/withConfigPlugins\");\n  _withConfigPlugins = function _withConfigPlugins() {\n    return data;\n  };\n  return data;\n}\nfunction _withInternal() {\n  var data = require(\"./plugins/withInternal\");\n  _withInternal = function _withInternal() {\n    return data;\n  };\n  return data;\n}\nfunction _resolvePackageJson() {\n  var data = require(\"./resolvePackageJson\");\n  _resolvePackageJson = function _resolvePackageJson() {\n    return data;\n  };\n  return data;\n}\nvar _Config = require(\"./Config.types\");\nObject.keys(_Config).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _Config[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Config[key];\n    }\n  });\n});\nfunction _isLegacyImportsEnabled() {\n  var data = require(\"./isLegacyImportsEnabled\");\n  _isLegacyImportsEnabled = function _isLegacyImportsEnabled() {\n    return data;\n  };\n  return data;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction reduceExpoObject(config) {\n  var _config$expo;\n  if (!config) return config === undefined ? null : config;\n  var _ref = (_config$expo = config.expo) !== null && _config$expo !== void 0 ? _config$expo : config,\n    mods = _ref.mods,\n    expo = _objectWithoutProperties(_ref, _excluded);\n  return {\n    expo: expo,\n    mods: mods\n  };\n}\nfunction getSupportedPlatforms(projectRoot) {\n  var platforms = [];\n  if (_resolveFrom().default.silent(projectRoot, 'react-native')) {\n    platforms.push('ios', 'android');\n  }\n  if (_resolveFrom().default.silent(projectRoot, 'react-native-web')) {\n    platforms.push('web');\n  }\n  return platforms;\n}\nfunction getConfig(projectRoot) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var paths = getConfigFilePaths(projectRoot);\n  var rawStaticConfig = paths.staticConfigPath ? (0, _getConfig().getStaticConfig)(paths.staticConfigPath) : null;\n  var rootConfig = rawStaticConfig || {};\n  var staticConfig = reduceExpoObject(rawStaticConfig) || {};\n  var _getPackageJsonAndPat = getPackageJsonAndPath(projectRoot),\n    _getPackageJsonAndPat2 = _slicedToArray(_getPackageJsonAndPat, 2),\n    packageJson = _getPackageJsonAndPat2[0],\n    packageJsonPath = _getPackageJsonAndPat2[1];\n  function fillAndReturnConfig(config, dynamicConfigObjectType) {\n    var configWithDefaultValues = Object.assign({}, ensureConfigHasDefaultValues({\n      projectRoot: projectRoot,\n      exp: config.expo,\n      pkg: packageJson,\n      skipSDKVersionRequirement: options.skipSDKVersionRequirement,\n      paths: paths,\n      packageJsonPath: packageJsonPath\n    }), {\n      mods: config.mods,\n      dynamicConfigObjectType: dynamicConfigObjectType,\n      rootConfig: rootConfig,\n      dynamicConfigPath: paths.dynamicConfigPath,\n      staticConfigPath: paths.staticConfigPath\n    });\n    if (options.isModdedConfig) {\n      var _config$mods;\n      configWithDefaultValues.exp.mods = (_config$mods = config.mods) !== null && _config$mods !== void 0 ? _config$mods : null;\n    }\n    configWithDefaultValues.exp = (0, _withConfigPlugins().withConfigPlugins)(configWithDefaultValues.exp, !!options.skipPlugins);\n    if (!options.isModdedConfig) {\n      delete configWithDefaultValues.exp.mods;\n    }\n    if (options.isPublicConfig) {\n      var _configWithDefaultVal, _configWithDefaultVal2, _configWithDefaultVal3, _configWithDefaultVal4;\n      delete configWithDefaultValues.exp._internal;\n      if (configWithDefaultValues.exp.hooks) {\n        delete configWithDefaultValues.exp.hooks;\n      }\n      if ((_configWithDefaultVal = configWithDefaultValues.exp.ios) !== null && _configWithDefaultVal !== void 0 && _configWithDefaultVal.config) {\n        delete configWithDefaultValues.exp.ios.config;\n      }\n      if ((_configWithDefaultVal2 = configWithDefaultValues.exp.android) !== null && _configWithDefaultVal2 !== void 0 && _configWithDefaultVal2.config) {\n        delete configWithDefaultValues.exp.android.config;\n      }\n      configWithDefaultValues.exp.currentFullName = (0, _getFullName().getFullName)(configWithDefaultValues.exp);\n      configWithDefaultValues.exp.originalFullName = (0, _getFullName().getFullName)(configWithDefaultValues.exp);\n      (_configWithDefaultVal3 = configWithDefaultValues.exp.updates) === null || _configWithDefaultVal3 === void 0 ? true : delete _configWithDefaultVal3.codeSigningCertificate;\n      (_configWithDefaultVal4 = configWithDefaultValues.exp.updates) === null || _configWithDefaultVal4 === void 0 ? true : delete _configWithDefaultVal4.codeSigningMetadata;\n    }\n    return configWithDefaultValues;\n  }\n  function getContextConfig(config) {\n    return ensureConfigHasDefaultValues({\n      projectRoot: projectRoot,\n      exp: config.expo,\n      pkg: packageJson,\n      skipSDKVersionRequirement: true,\n      paths: paths,\n      packageJsonPath: packageJsonPath\n    }).exp;\n  }\n  if (paths.dynamicConfigPath) {\n    var _ref2 = (0, _getConfig().getDynamicConfig)(paths.dynamicConfigPath, {\n        projectRoot: projectRoot,\n        staticConfigPath: paths.staticConfigPath,\n        packageJsonPath: packageJsonPath,\n        config: getContextConfig(staticConfig)\n      }),\n      exportedObjectType = _ref2.exportedObjectType,\n      rawDynamicConfig = _ref2.config;\n    var dynamicConfig = reduceExpoObject(rawDynamicConfig) || {};\n    return fillAndReturnConfig(dynamicConfig, exportedObjectType);\n  }\n  return fillAndReturnConfig(staticConfig || {}, null);\n}\nfunction getPackageJson(projectRoot) {\n  var _getPackageJsonAndPat3 = getPackageJsonAndPath(projectRoot),\n    _getPackageJsonAndPat4 = _slicedToArray(_getPackageJsonAndPat3, 1),\n    pkg = _getPackageJsonAndPat4[0];\n  return pkg;\n}\nfunction getPackageJsonAndPath(projectRoot) {\n  var packageJsonPath = (0, _resolvePackageJson().getRootPackageJsonPath)(projectRoot);\n  return [_jsonFile().default.read(packageJsonPath), packageJsonPath];\n}\nfunction readConfigJson(projectRoot) {\n  var skipValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var skipSDKVersionRequirement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var paths = getConfigFilePaths(projectRoot);\n  var rawStaticConfig = paths.staticConfigPath ? (0, _getConfig().getStaticConfig)(paths.staticConfigPath) : null;\n  var getConfigName = function getConfigName() {\n    if (paths.staticConfigPath) return \" `\" + _path().default.basename(paths.staticConfigPath) + \"`\";\n    return '';\n  };\n  var outputRootConfig = rawStaticConfig;\n  if (outputRootConfig === null || typeof outputRootConfig !== 'object') {\n    if (skipValidation) {\n      outputRootConfig = {\n        expo: {}\n      };\n    } else {\n      throw new (_Errors().ConfigError)(\"Project at path \" + _path().default.resolve(projectRoot) + \" does not contain a valid Expo config\" + getConfigName(), 'NOT_OBJECT');\n    }\n  }\n  var exp = outputRootConfig.expo;\n  if (exp === null || typeof exp !== 'object') {\n    throw new (_Errors().ConfigError)(\"Property 'expo' in\" + getConfigName() + \" for project at path \" + _path().default.resolve(projectRoot) + \" is not an object. Please make sure\" + getConfigName() + \" includes a managed Expo app config like this: \" + APP_JSON_EXAMPLE, 'NO_EXPO');\n  }\n  exp = Object.assign({}, exp);\n  var _getPackageJsonAndPat5 = getPackageJsonAndPath(projectRoot),\n    _getPackageJsonAndPat6 = _slicedToArray(_getPackageJsonAndPat5, 2),\n    pkg = _getPackageJsonAndPat6[0],\n    packageJsonPath = _getPackageJsonAndPat6[1];\n  return Object.assign({}, ensureConfigHasDefaultValues({\n    projectRoot: projectRoot,\n    exp: exp,\n    pkg: pkg,\n    skipSDKVersionRequirement: skipSDKVersionRequirement,\n    paths: paths,\n    packageJsonPath: packageJsonPath\n  }), {\n    mods: null,\n    dynamicConfigObjectType: null,\n    rootConfig: Object.assign({}, outputRootConfig)\n  }, paths);\n}\nfunction getConfigFilePaths(projectRoot) {\n  var customPaths = getCustomConfigFilePaths(projectRoot);\n  if (customPaths) {\n    return customPaths;\n  }\n  return {\n    dynamicConfigPath: getDynamicConfigFilePath(projectRoot),\n    staticConfigPath: getStaticConfigFilePath(projectRoot)\n  };\n}\nfunction getCustomConfigFilePaths(projectRoot) {\n  if (!customConfigPaths[projectRoot]) {\n    return null;\n  }\n  if (isDynamicFilePath(customConfigPaths[projectRoot])) {\n    return {\n      dynamicConfigPath: customConfigPaths[projectRoot],\n      staticConfigPath: null\n    };\n  }\n  return {\n    staticConfigPath: customConfigPaths[projectRoot],\n    dynamicConfigPath: null\n  };\n}\nfunction getDynamicConfigFilePath(projectRoot) {\n  for (var fileName of ['app.config.ts', 'app.config.js']) {\n    var configPath = _path().default.join(projectRoot, fileName);\n    if (_fs().default.existsSync(configPath)) {\n      return configPath;\n    }\n  }\n  return null;\n}\nfunction getStaticConfigFilePath(projectRoot) {\n  for (var fileName of ['app.config.json', 'app.json']) {\n    var configPath = _path().default.join(projectRoot, fileName);\n    if (_fs().default.existsSync(configPath)) {\n      return configPath;\n    }\n  }\n  return null;\n}\nfunction findConfigFile(projectRoot) {\n  var configPath;\n  if (customConfigPaths[projectRoot]) {\n    configPath = customConfigPaths[projectRoot];\n    return {\n      configPath: configPath,\n      configName: _path().default.basename(configPath),\n      configNamespace: 'expo'\n    };\n  } else {\n    configPath = _path().default.join(projectRoot, 'app.config.json');\n    if (!_fs().default.existsSync(configPath)) {\n      configPath = _path().default.join(projectRoot, 'app.json');\n    }\n  }\n  return {\n    configPath: configPath,\n    configName: _path().default.basename(configPath),\n    configNamespace: 'expo'\n  };\n}\nfunction configFilename(projectRoot) {\n  return findConfigFile(projectRoot).configName;\n}\nfunction readExpRcAsync(_x) {\n  return _readExpRcAsync.apply(this, arguments);\n}\nfunction _readExpRcAsync() {\n  _readExpRcAsync = _asyncToGenerator(function* (projectRoot) {\n    var expRcPath = _path().default.join(projectRoot, '.exprc');\n    return yield _jsonFile().default.readAsync(expRcPath, {\n      json5: true,\n      cantReadFileDefault: {}\n    });\n  });\n  return _readExpRcAsync.apply(this, arguments);\n}\nvar customConfigPaths = {};\nfunction resetCustomConfigPaths() {\n  for (var key of Object.keys(customConfigPaths)) {\n    delete customConfigPaths[key];\n  }\n}\nfunction setCustomConfigPath(projectRoot, configPath) {\n  customConfigPaths[projectRoot] = configPath;\n}\nfunction modifyConfigAsync(_x2, _x3) {\n  return _modifyConfigAsync.apply(this, arguments);\n}\nfunction _modifyConfigAsync() {\n  _modifyConfigAsync = _asyncToGenerator(function* (projectRoot, modifications) {\n    var readOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var writeOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var config = getConfig(projectRoot, readOptions);\n    if (config.dynamicConfigPath) {\n      return {\n        type: 'warn',\n        message: \"Cannot automatically write to dynamic config at: \" + _path().default.relative(projectRoot, config.dynamicConfigPath),\n        config: null\n      };\n    } else if (config.staticConfigPath) {\n      var outputConfig;\n      if (config.rootConfig.expo) {\n        outputConfig = Object.assign({}, config.rootConfig, {\n          expo: Object.assign({}, config.rootConfig.expo, modifications)\n        });\n      } else {\n        outputConfig = Object.assign({}, config.rootConfig, modifications);\n      }\n      if (!writeOptions.dryRun) {\n        yield _jsonFile().default.writeAsync(config.staticConfigPath, outputConfig, {\n          json5: false\n        });\n      }\n      return {\n        type: 'success',\n        config: outputConfig\n      };\n    }\n    return {\n      type: 'fail',\n      message: 'No config exists',\n      config: null\n    };\n  });\n  return _modifyConfigAsync.apply(this, arguments);\n}\nvar APP_JSON_EXAMPLE = JSON.stringify({\n  expo: {\n    name: 'My app',\n    slug: 'my-app',\n    sdkVersion: '...'\n  }\n});\nfunction ensureConfigHasDefaultValues(_ref3) {\n  var projectRoot = _ref3.projectRoot,\n    exp = _ref3.exp,\n    pkg = _ref3.pkg,\n    paths = _ref3.paths,\n    packageJsonPath = _ref3.packageJsonPath,\n    _ref3$skipSDKVersionR = _ref3.skipSDKVersionRequirement,\n    skipSDKVersionRequirement = _ref3$skipSDKVersionR === void 0 ? false : _ref3$skipSDKVersionR;\n  var _exp$name, _exp$slug, _exp$version;\n  if (!exp) {\n    exp = {};\n  }\n  exp = (0, _withInternal().withInternal)(exp, Object.assign({\n    projectRoot: projectRoot\n  }, paths !== null && paths !== void 0 ? paths : {}, {\n    packageJsonPath: packageJsonPath\n  }));\n  var pkgName = typeof pkg.name === 'string' ? pkg.name : _path().default.basename(projectRoot);\n  var pkgVersion = typeof pkg.version === 'string' ? pkg.version : '1.0.0';\n  var pkgWithDefaults = Object.assign({}, pkg, {\n    name: pkgName,\n    version: pkgVersion\n  });\n  var name = (_exp$name = exp.name) !== null && _exp$name !== void 0 ? _exp$name : pkgName;\n  var slug = (_exp$slug = exp.slug) !== null && _exp$slug !== void 0 ? _exp$slug : (0, _slugify().default)(name.toLowerCase());\n  var version = (_exp$version = exp.version) !== null && _exp$version !== void 0 ? _exp$version : pkgVersion;\n  var description = exp.description;\n  if (!description && typeof pkg.description === 'string') {\n    description = pkg.description;\n  }\n  var expWithDefaults = Object.assign({}, exp, {\n    name: name,\n    slug: slug,\n    version: version,\n    description: description\n  });\n  var sdkVersion;\n  try {\n    sdkVersion = (0, _Project().getExpoSDKVersion)(projectRoot, expWithDefaults);\n  } catch (error) {\n    if (!skipSDKVersionRequirement) throw error;\n  }\n  var platforms = exp.platforms;\n  if (!platforms) {\n    platforms = getSupportedPlatforms(projectRoot);\n  }\n  return {\n    exp: Object.assign({}, expWithDefaults, {\n      sdkVersion: sdkVersion,\n      platforms: platforms\n    }),\n    pkg: pkgWithDefaults\n  };\n}\nfunction writeConfigJsonAsync(_x4, _x5) {\n  return _writeConfigJsonAsync.apply(this, arguments);\n}\nfunction _writeConfigJsonAsync() {\n  _writeConfigJsonAsync = _asyncToGenerator(function* (projectRoot, options) {\n    var paths = getConfigFilePaths(projectRoot);\n    var _readConfigJson = readConfigJson(projectRoot),\n      exp = _readConfigJson.exp,\n      pkg = _readConfigJson.pkg,\n      rootConfig = _readConfigJson.rootConfig,\n      dynamicConfigObjectType = _readConfigJson.dynamicConfigObjectType;\n    exp = Object.assign({}, rootConfig.expo, options);\n    rootConfig = Object.assign({}, rootConfig, {\n      expo: exp\n    });\n    if (paths.staticConfigPath) {\n      yield _jsonFile().default.writeAsync(paths.staticConfigPath, rootConfig, {\n        json5: false\n      });\n    } else {\n      console.log('Failed to write to config: ', options);\n    }\n    return Object.assign({\n      exp: exp,\n      pkg: pkg,\n      rootConfig: rootConfig,\n      dynamicConfigObjectType: dynamicConfigObjectType\n    }, paths);\n  });\n  return _writeConfigJsonAsync.apply(this, arguments);\n}\nvar DEFAULT_BUILD_PATH = \"web-build\";\nfunction getWebOutputPath() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _expo$web, _expo$web$build;\n  if (process.env.WEBPACK_BUILD_OUTPUT_PATH) {\n    return process.env.WEBPACK_BUILD_OUTPUT_PATH;\n  }\n  var expo = config.expo || config || {};\n  return (expo === null || expo === void 0 ? void 0 : (_expo$web = expo.web) === null || _expo$web === void 0 ? void 0 : (_expo$web$build = _expo$web.build) === null || _expo$web$build === void 0 ? void 0 : _expo$web$build.output) || DEFAULT_BUILD_PATH;\n}\nfunction getNameFromConfig() {\n  var exp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var appManifest = exp.expo || exp;\n  var _appManifest$web = appManifest.web,\n    web = _appManifest$web === void 0 ? {} : _appManifest$web;\n  var appName = exp.displayName || appManifest.displayName || appManifest.name;\n  var webName = web.name || appName;\n  return {\n    appName: appName,\n    webName: webName\n  };\n}\nfunction getDefaultTarget(projectRoot, exp) {\n  var _exp;\n  (_exp = exp) !== null && _exp !== void 0 ? _exp : exp = getConfig(projectRoot, {\n    skipSDKVersionRequirement: true\n  }).exp;\n  if (exp.sdkVersion && exp.sdkVersion !== 'UNVERSIONED' && _semver().default.lt(exp.sdkVersion, '37.0.0')) {\n    return 'managed';\n  }\n  return isBareWorkflowProject(projectRoot) ? 'bare' : 'managed';\n}\nfunction isBareWorkflowProject(projectRoot) {\n  var _getPackageJsonAndPat7 = getPackageJsonAndPath(projectRoot),\n    _getPackageJsonAndPat8 = _slicedToArray(_getPackageJsonAndPat7, 1),\n    pkg = _getPackageJsonAndPat8[0];\n  if (pkg.dependencies && pkg.dependencies.expokit) {\n    return false;\n  }\n  var xcodeprojFiles = (0, _glob().sync)('ios/**/*.xcodeproj', {\n    absolute: true,\n    cwd: projectRoot\n  });\n  if (xcodeprojFiles.length) {\n    return true;\n  }\n  var gradleFiles = (0, _glob().sync)('android/**/*.gradle', {\n    absolute: true,\n    cwd: projectRoot\n  });\n  if (gradleFiles.length) {\n    return true;\n  }\n  return false;\n}\nfunction isDynamicFilePath(filePath) {\n  return !!filePath.match(/\\.[j|t]s$/);\n}\nfunction getProjectConfigDescription(projectRoot) {\n  var paths = getConfigFilePaths(projectRoot);\n  return getProjectConfigDescriptionWithPaths(projectRoot, paths);\n}\nfunction getProjectConfigDescriptionWithPaths(projectRoot, projectConfig) {\n  if (projectConfig.dynamicConfigPath) {\n    var relativeDynamicConfigPath = _path().default.relative(projectRoot, projectConfig.dynamicConfigPath);\n    if (projectConfig.staticConfigPath) {\n      return relativeDynamicConfigPath + \" or \" + _path().default.relative(projectRoot, projectConfig.staticConfigPath);\n    }\n    return relativeDynamicConfigPath;\n  } else if (projectConfig.staticConfigPath) {\n    return _path().default.relative(projectRoot, projectConfig.staticConfigPath);\n  }\n  return 'app.json';\n}","map":{"version":3,"sources":["../src/Config.ts"],"names":["reduceExpoObject","config","undefined","mods","expo","getSupportedPlatforms","projectRoot","platforms","resolveFrom","silent","push","getConfig","options","paths","getConfigFilePaths","rawStaticConfig","staticConfigPath","rootConfig","staticConfig","packageJson","packageJsonPath","getPackageJsonAndPath","fillAndReturnConfig","dynamicConfigObjectType","configWithDefaultValues","ensureConfigHasDefaultValues","exp","pkg","skipSDKVersionRequirement","dynamicConfigPath","isModdedConfig","skipPlugins","isPublicConfig","_internal","hooks","ios","android","currentFullName","originalFullName","updates","codeSigningCertificate","codeSigningMetadata","getContextConfig","exportedObjectType","rawDynamicConfig","dynamicConfig","getPackageJson","JsonFile","read","readConfigJson","skipValidation","getConfigName","path","basename","outputRootConfig","ConfigError","resolve","APP_JSON_EXAMPLE","customPaths","getCustomConfigFilePaths","getDynamicConfigFilePath","getStaticConfigFilePath","customConfigPaths","isDynamicFilePath","fileName","configPath","join","fs","existsSync","findConfigFile","configName","configNamespace","configFilename","readExpRcAsync","expRcPath","readAsync","json5","cantReadFileDefault","resetCustomConfigPaths","key","Object","keys","setCustomConfigPath","modifyConfigAsync","modifications","readOptions","writeOptions","type","message","relative","outputConfig","dryRun","writeAsync","stringify","name","slug","sdkVersion","pkgName","pkgVersion","version","pkgWithDefaults","toLowerCase","description","expWithDefaults","error","writeConfigJsonAsync","console","log","DEFAULT_BUILD_PATH","getWebOutputPath","process","env","WEBPACK_BUILD_OUTPUT_PATH","web","build","output","getNameFromConfig","appManifest","appName","displayName","webName","getDefaultTarget","semver","lt","isBareWorkflowProject","dependencies","expokit","xcodeprojFiles","absolute","cwd","length","gradleFiles","filePath","match","getProjectConfigDescription","getProjectConfigDescriptionWithPaths","projectConfig","relativeDynamicConfigPath"],"mappings":"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","sourcesContent":["import { ModConfig } from '@expo/config-plugins';\nimport JsonFile, { JSONObject } from '@expo/json-file';\nimport fs from 'fs';\nimport { sync as globSync } from 'glob';\nimport path from 'path';\nimport resolveFrom from 'resolve-from';\nimport semver from 'semver';\nimport slugify from 'slugify';\n\nimport {\n  AppJSONConfig,\n  ConfigFilePaths,\n  ExpoConfig,\n  ExpRc,\n  GetConfigOptions,\n  PackageJSONConfig,\n  Platform,\n  ProjectConfig,\n  ProjectTarget,\n  WriteConfigOptions,\n} from './Config.types';\nimport { ConfigError } from './Errors';\nimport { getExpoSDKVersion } from './Project';\nimport { getDynamicConfig, getStaticConfig } from './getConfig';\nimport { getFullName } from './getFullName';\nimport { withConfigPlugins } from './plugins/withConfigPlugins';\nimport { withInternal } from './plugins/withInternal';\nimport { getRootPackageJsonPath } from './resolvePackageJson';\n\ntype SplitConfigs = { expo: ExpoConfig; mods: ModConfig };\n\n/**\n * If a config has an `expo` object then that will be used as the config.\n * This method reduces out other top level values if an `expo` object exists.\n *\n * @param config Input config object to reduce\n */\nfunction reduceExpoObject(config?: any): SplitConfigs {\n  if (!config) return config === undefined ? null : config;\n\n  const { mods, ...expo } = config.expo ?? config;\n\n  return {\n    expo,\n    mods,\n  };\n}\n\n/**\n * Get all platforms that a project is currently capable of running.\n *\n * @param projectRoot\n * @param exp\n */\nfunction getSupportedPlatforms(projectRoot: string): Platform[] {\n  const platforms: Platform[] = [];\n  if (resolveFrom.silent(projectRoot, 'react-native')) {\n    platforms.push('ios', 'android');\n  }\n  if (resolveFrom.silent(projectRoot, 'react-native-web')) {\n    platforms.push('web');\n  }\n  return platforms;\n}\n\n/**\n * Evaluate the config for an Expo project.\n * If a function is exported from the `app.config.js` then a partial config will be passed as an argument.\n * The partial config is composed from any existing app.json, and certain fields from the `package.json` like name and description.\n *\n * If options.isPublicConfig is true, the Expo config will include only public-facing options (omitting private keys).\n * The resulting config should be suitable for hosting or embedding in a publicly readable location.\n *\n * **Example**\n * ```js\n * module.exports = function({ config }) {\n *   // mutate the config before returning it.\n *   config.slug = 'new slug'\n *   return { expo: config };\n * }\n * ```\n *\n * **Supports**\n * - `app.config.ts`\n * - `app.config.js`\n * - `app.config.json`\n * - `app.json`\n *\n * @param projectRoot the root folder containing all of your application code\n * @param options enforce criteria for a project config\n */\nexport function getConfig(projectRoot: string, options: GetConfigOptions = {}): ProjectConfig {\n  const paths = getConfigFilePaths(projectRoot);\n\n  const rawStaticConfig = paths.staticConfigPath ? getStaticConfig(paths.staticConfigPath) : null;\n  // For legacy reasons, always return an object.\n  const rootConfig = (rawStaticConfig || {}) as AppJSONConfig;\n  const staticConfig = reduceExpoObject(rawStaticConfig) || {};\n\n  // Can only change the package.json location if an app.json or app.config.json exists\n  const [packageJson, packageJsonPath] = getPackageJsonAndPath(projectRoot);\n\n  function fillAndReturnConfig(config: SplitConfigs, dynamicConfigObjectType: string | null) {\n    const configWithDefaultValues = {\n      ...ensureConfigHasDefaultValues({\n        projectRoot,\n        exp: config.expo,\n        pkg: packageJson,\n        skipSDKVersionRequirement: options.skipSDKVersionRequirement,\n        paths,\n        packageJsonPath,\n      }),\n      mods: config.mods,\n      dynamicConfigObjectType,\n      rootConfig,\n      dynamicConfigPath: paths.dynamicConfigPath,\n      staticConfigPath: paths.staticConfigPath,\n    };\n\n    if (options.isModdedConfig) {\n      // @ts-ignore: Add the mods back to the object.\n      configWithDefaultValues.exp.mods = config.mods ?? null;\n    }\n\n    // Apply static json plugins, should be done after _internal\n    configWithDefaultValues.exp = withConfigPlugins(\n      configWithDefaultValues.exp,\n      !!options.skipPlugins\n    );\n\n    if (!options.isModdedConfig) {\n      // @ts-ignore: Delete mods added by static plugins when they won't have a chance to be evaluated\n      delete configWithDefaultValues.exp.mods;\n    }\n\n    if (options.isPublicConfig) {\n      // Remove internal values with references to user's file paths from the public config.\n      delete configWithDefaultValues.exp._internal;\n\n      if (configWithDefaultValues.exp.hooks) {\n        delete configWithDefaultValues.exp.hooks;\n      }\n      if (configWithDefaultValues.exp.ios?.config) {\n        delete configWithDefaultValues.exp.ios.config;\n      }\n      if (configWithDefaultValues.exp.android?.config) {\n        delete configWithDefaultValues.exp.android.config;\n      }\n\n      // These value will be overwritten when the manifest is being served from the host (i.e. not completely accurate).\n      // @ts-ignore: currentFullName not on type yet.\n      configWithDefaultValues.exp.currentFullName = getFullName(configWithDefaultValues.exp);\n      // @ts-ignore: originalFullName not on type yet.\n      configWithDefaultValues.exp.originalFullName = getFullName(configWithDefaultValues.exp);\n\n      delete configWithDefaultValues.exp.updates?.codeSigningCertificate;\n      delete configWithDefaultValues.exp.updates?.codeSigningMetadata;\n    }\n\n    return configWithDefaultValues;\n  }\n\n  // Fill in the static config\n  function getContextConfig(config: SplitConfigs) {\n    return ensureConfigHasDefaultValues({\n      projectRoot,\n      exp: config.expo,\n      pkg: packageJson,\n      skipSDKVersionRequirement: true,\n      paths,\n      packageJsonPath,\n    }).exp;\n  }\n\n  if (paths.dynamicConfigPath) {\n    // No app.config.json or app.json but app.config.js\n    const { exportedObjectType, config: rawDynamicConfig } = getDynamicConfig(\n      paths.dynamicConfigPath,\n      {\n        projectRoot,\n        staticConfigPath: paths.staticConfigPath,\n        packageJsonPath,\n        config: getContextConfig(staticConfig),\n      }\n    );\n    // Allow for the app.config.js to `export default null;`\n    // Use `dynamicConfigPath` to detect if a dynamic config exists.\n    const dynamicConfig = reduceExpoObject(rawDynamicConfig) || {};\n    return fillAndReturnConfig(dynamicConfig, exportedObjectType);\n  }\n\n  // No app.config.js but json or no config\n  return fillAndReturnConfig(staticConfig || {}, null);\n}\n\nexport function getPackageJson(projectRoot: string): PackageJSONConfig {\n  const [pkg] = getPackageJsonAndPath(projectRoot);\n  return pkg;\n}\n\nfunction getPackageJsonAndPath(projectRoot: string): [PackageJSONConfig, string] {\n  const packageJsonPath = getRootPackageJsonPath(projectRoot);\n  return [JsonFile.read(packageJsonPath), packageJsonPath];\n}\n\nexport function readConfigJson(\n  projectRoot: string,\n  skipValidation: boolean = false,\n  skipSDKVersionRequirement: boolean = false\n): ProjectConfig {\n  const paths = getConfigFilePaths(projectRoot);\n\n  const rawStaticConfig = paths.staticConfigPath ? getStaticConfig(paths.staticConfigPath) : null;\n\n  const getConfigName = (): string => {\n    if (paths.staticConfigPath) return ` \\`${path.basename(paths.staticConfigPath)}\\``;\n    return '';\n  };\n\n  let outputRootConfig = rawStaticConfig as JSONObject | null;\n  if (outputRootConfig === null || typeof outputRootConfig !== 'object') {\n    if (skipValidation) {\n      outputRootConfig = { expo: {} };\n    } else {\n      throw new ConfigError(\n        `Project at path ${path.resolve(\n          projectRoot\n        )} does not contain a valid Expo config${getConfigName()}`,\n        'NOT_OBJECT'\n      );\n    }\n  }\n  let exp = outputRootConfig.expo as Partial<ExpoConfig>;\n  if (exp === null || typeof exp !== 'object') {\n    throw new ConfigError(\n      `Property 'expo' in${getConfigName()} for project at path ${path.resolve(\n        projectRoot\n      )} is not an object. Please make sure${getConfigName()} includes a managed Expo app config like this: ${APP_JSON_EXAMPLE}`,\n      'NO_EXPO'\n    );\n  }\n\n  exp = { ...exp };\n\n  const [pkg, packageJsonPath] = getPackageJsonAndPath(projectRoot);\n\n  return {\n    ...ensureConfigHasDefaultValues({\n      projectRoot,\n      exp,\n      pkg,\n      skipSDKVersionRequirement,\n      paths,\n      packageJsonPath,\n    }),\n    mods: null,\n    dynamicConfigObjectType: null,\n    rootConfig: { ...outputRootConfig } as AppJSONConfig,\n    ...paths,\n  };\n}\n\n/**\n * Get the static and dynamic config paths for a project. Also accounts for custom paths.\n *\n * @param projectRoot\n */\nexport function getConfigFilePaths(projectRoot: string): ConfigFilePaths {\n  const customPaths = getCustomConfigFilePaths(projectRoot);\n  if (customPaths) {\n    return customPaths;\n  }\n\n  return {\n    dynamicConfigPath: getDynamicConfigFilePath(projectRoot),\n    staticConfigPath: getStaticConfigFilePath(projectRoot),\n  };\n}\n\nfunction getCustomConfigFilePaths(projectRoot: string): ConfigFilePaths | null {\n  if (!customConfigPaths[projectRoot]) {\n    return null;\n  }\n  // If the user picks a custom config path, we will only use that and skip searching for a secondary config.\n  if (isDynamicFilePath(customConfigPaths[projectRoot])) {\n    return {\n      dynamicConfigPath: customConfigPaths[projectRoot],\n      staticConfigPath: null,\n    };\n  }\n  // Anything that's not js or ts will be treated as json.\n  return { staticConfigPath: customConfigPaths[projectRoot], dynamicConfigPath: null };\n}\n\nfunction getDynamicConfigFilePath(projectRoot: string): string | null {\n  for (const fileName of ['app.config.ts', 'app.config.js']) {\n    const configPath = path.join(projectRoot, fileName);\n    if (fs.existsSync(configPath)) {\n      return configPath;\n    }\n  }\n  return null;\n}\n\nfunction getStaticConfigFilePath(projectRoot: string): string | null {\n  for (const fileName of ['app.config.json', 'app.json']) {\n    const configPath = path.join(projectRoot, fileName);\n    if (fs.existsSync(configPath)) {\n      return configPath;\n    }\n  }\n  return null;\n}\n\n// TODO: This should account for dynamic configs\nexport function findConfigFile(projectRoot: string): {\n  configPath: string;\n  configName: string;\n  configNamespace: 'expo';\n} {\n  let configPath: string;\n  // Check for a custom config path first.\n  if (customConfigPaths[projectRoot]) {\n    configPath = customConfigPaths[projectRoot];\n    // We shouldn't verify if the file exists because\n    // the user manually specified that this path should be used.\n    return {\n      configPath,\n      configName: path.basename(configPath),\n      configNamespace: 'expo',\n    };\n  } else {\n    // app.config.json takes higher priority over app.json\n    configPath = path.join(projectRoot, 'app.config.json');\n    if (!fs.existsSync(configPath)) {\n      configPath = path.join(projectRoot, 'app.json');\n    }\n  }\n\n  return {\n    configPath,\n    configName: path.basename(configPath),\n    configNamespace: 'expo',\n  };\n}\n\n// TODO: deprecate\nexport function configFilename(projectRoot: string): string {\n  return findConfigFile(projectRoot).configName;\n}\n\nexport async function readExpRcAsync(projectRoot: string): Promise<ExpRc> {\n  const expRcPath = path.join(projectRoot, '.exprc');\n  return await JsonFile.readAsync(expRcPath, { json5: true, cantReadFileDefault: {} });\n}\n\nconst customConfigPaths: { [projectRoot: string]: string } = {};\n\nexport function resetCustomConfigPaths(): void {\n  for (const key of Object.keys(customConfigPaths)) {\n    delete customConfigPaths[key];\n  }\n}\n\nexport function setCustomConfigPath(projectRoot: string, configPath: string): void {\n  customConfigPaths[projectRoot] = configPath;\n}\n\n/**\n * Attempt to modify an Expo project config.\n * This will only fully work if the project is using static configs only.\n * Otherwise 'warn' | 'fail' will return with a message about why the config couldn't be updated.\n * The potentially modified config object will be returned for testing purposes.\n *\n * @param projectRoot\n * @param modifications modifications to make to an existing config\n * @param readOptions options for reading the current config file\n * @param writeOptions If true, the static config file will not be rewritten\n */\nexport async function modifyConfigAsync(\n  projectRoot: string,\n  modifications: Partial<ExpoConfig>,\n  readOptions: GetConfigOptions = {},\n  writeOptions: WriteConfigOptions = {}\n): Promise<{\n  type: 'success' | 'warn' | 'fail';\n  message?: string;\n  config: AppJSONConfig | null;\n}> {\n  const config = getConfig(projectRoot, readOptions);\n  if (config.dynamicConfigPath) {\n    // We cannot automatically write to a dynamic config.\n    /* Currently we should just use the safest approach possible, informing the user that they'll need to manually modify their dynamic config.\n\n    if (config.staticConfigPath) {\n      // Both a dynamic and a static config exist.\n      if (config.dynamicConfigObjectType === 'function') {\n        // The dynamic config exports a function, this means it possibly extends the static config.\n      } else {\n        // Dynamic config ignores the static config, there isn't a reason to automatically write to it.\n        // Instead we should warn the user to add values to their dynamic config.\n      }\n    }\n    */\n    return {\n      type: 'warn',\n      message: `Cannot automatically write to dynamic config at: ${path.relative(\n        projectRoot,\n        config.dynamicConfigPath\n      )}`,\n      config: null,\n    };\n  } else if (config.staticConfigPath) {\n    // Static with no dynamic config, this means we can append to the config automatically.\n    let outputConfig: AppJSONConfig;\n    // If the config has an expo object (app.json) then append the options to that object.\n    if (config.rootConfig.expo) {\n      outputConfig = {\n        ...config.rootConfig,\n        expo: { ...config.rootConfig.expo, ...modifications },\n      };\n    } else {\n      // Otherwise (app.config.json) just add the config modification to the top most level.\n      outputConfig = { ...config.rootConfig, ...modifications };\n    }\n    if (!writeOptions.dryRun) {\n      await JsonFile.writeAsync(config.staticConfigPath, outputConfig, { json5: false });\n    }\n    return { type: 'success', config: outputConfig };\n  }\n\n  return { type: 'fail', message: 'No config exists', config: null };\n}\n\nconst APP_JSON_EXAMPLE = JSON.stringify({\n  expo: {\n    name: 'My app',\n    slug: 'my-app',\n    sdkVersion: '...',\n  },\n});\n\nfunction ensureConfigHasDefaultValues({\n  projectRoot,\n  exp,\n  pkg,\n  paths,\n  packageJsonPath,\n  skipSDKVersionRequirement = false,\n}: {\n  projectRoot: string;\n  exp: Partial<ExpoConfig> | null;\n  pkg: JSONObject;\n  skipSDKVersionRequirement?: boolean;\n  paths?: ConfigFilePaths;\n  packageJsonPath?: string;\n}): { exp: ExpoConfig; pkg: PackageJSONConfig } {\n  if (!exp) {\n    exp = {};\n  }\n  exp = withInternal(exp as any, {\n    projectRoot,\n    ...(paths ?? {}),\n    packageJsonPath,\n  });\n  // Defaults for package.json fields\n  const pkgName = typeof pkg.name === 'string' ? pkg.name : path.basename(projectRoot);\n  const pkgVersion = typeof pkg.version === 'string' ? pkg.version : '1.0.0';\n\n  const pkgWithDefaults = { ...pkg, name: pkgName, version: pkgVersion };\n\n  // Defaults for app.json/app.config.js fields\n  const name = exp.name ?? pkgName;\n  const slug = exp.slug ?? slugify(name.toLowerCase());\n  const version = exp.version ?? pkgVersion;\n  let description = exp.description;\n  if (!description && typeof pkg.description === 'string') {\n    description = pkg.description;\n  }\n\n  const expWithDefaults = { ...exp, name, slug, version, description };\n\n  let sdkVersion;\n  try {\n    sdkVersion = getExpoSDKVersion(projectRoot, expWithDefaults);\n  } catch (error) {\n    if (!skipSDKVersionRequirement) throw error;\n  }\n\n  let platforms = exp.platforms;\n  if (!platforms) {\n    platforms = getSupportedPlatforms(projectRoot);\n  }\n\n  return {\n    exp: { ...expWithDefaults, sdkVersion, platforms },\n    pkg: pkgWithDefaults,\n  };\n}\n\nexport async function writeConfigJsonAsync(\n  projectRoot: string,\n  options: object\n): Promise<ProjectConfig> {\n  const paths = getConfigFilePaths(projectRoot);\n  let { exp, pkg, rootConfig, dynamicConfigObjectType } = readConfigJson(projectRoot);\n  exp = { ...rootConfig.expo, ...options };\n  rootConfig = { ...rootConfig, expo: exp };\n\n  if (paths.staticConfigPath) {\n    await JsonFile.writeAsync(paths.staticConfigPath, rootConfig, { json5: false });\n  } else {\n    console.log('Failed to write to config: ', options);\n  }\n\n  return {\n    exp,\n    pkg,\n    rootConfig,\n    dynamicConfigObjectType,\n    ...paths,\n  };\n}\nconst DEFAULT_BUILD_PATH = `web-build`;\n\nexport function getWebOutputPath(config: { [key: string]: any } = {}): string {\n  if (process.env.WEBPACK_BUILD_OUTPUT_PATH) {\n    return process.env.WEBPACK_BUILD_OUTPUT_PATH;\n  }\n  const expo = config.expo || config || {};\n  return expo?.web?.build?.output || DEFAULT_BUILD_PATH;\n}\n\nexport function getNameFromConfig(exp: Record<string, any> = {}): {\n  appName?: string;\n  webName?: string;\n} {\n  // For RN CLI support\n  const appManifest = exp.expo || exp;\n  const { web = {} } = appManifest;\n\n  // rn-cli apps use a displayName value as well.\n  const appName = exp.displayName || appManifest.displayName || appManifest.name;\n  const webName = web.name || appName;\n\n  return {\n    appName,\n    webName,\n  };\n}\n\nexport function getDefaultTarget(\n  projectRoot: string,\n  exp?: Pick<ExpoConfig, 'sdkVersion'>\n): ProjectTarget {\n  exp ??= getConfig(projectRoot, { skipSDKVersionRequirement: true }).exp;\n\n  // before SDK 37, always default to managed to preserve previous behavior\n  if (exp.sdkVersion && exp.sdkVersion !== 'UNVERSIONED' && semver.lt(exp.sdkVersion, '37.0.0')) {\n    return 'managed';\n  }\n  return isBareWorkflowProject(projectRoot) ? 'bare' : 'managed';\n}\n\nfunction isBareWorkflowProject(projectRoot: string): boolean {\n  const [pkg] = getPackageJsonAndPath(projectRoot);\n\n  if (pkg.dependencies && pkg.dependencies.expokit) {\n    return false;\n  }\n\n  const xcodeprojFiles = globSync('ios/**/*.xcodeproj', {\n    absolute: true,\n    cwd: projectRoot,\n  });\n  if (xcodeprojFiles.length) {\n    return true;\n  }\n  const gradleFiles = globSync('android/**/*.gradle', {\n    absolute: true,\n    cwd: projectRoot,\n  });\n  if (gradleFiles.length) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * true if the file is .js or .ts\n *\n * @param filePath\n */\nfunction isDynamicFilePath(filePath: string): boolean {\n  return !!filePath.match(/\\.[j|t]s$/);\n}\n\n/**\n * Return a useful name describing the project config.\n * - dynamic: app.config.js\n * - static: app.json\n * - custom path app config relative to root folder\n * - both: app.config.js or app.json\n */\nexport function getProjectConfigDescription(projectRoot: string): string {\n  const paths = getConfigFilePaths(projectRoot);\n  return getProjectConfigDescriptionWithPaths(projectRoot, paths);\n}\n\n/**\n * Returns a string describing the configurations used for the given project root.\n * Will return null if no config is found.\n *\n * @param projectRoot\n * @param projectConfig\n */\nexport function getProjectConfigDescriptionWithPaths(\n  projectRoot: string,\n  projectConfig: ConfigFilePaths\n): string {\n  if (projectConfig.dynamicConfigPath) {\n    const relativeDynamicConfigPath = path.relative(projectRoot, projectConfig.dynamicConfigPath);\n    if (projectConfig.staticConfigPath) {\n      return `${relativeDynamicConfigPath} or ${path.relative(\n        projectRoot,\n        projectConfig.staticConfigPath\n      )}`;\n    }\n    return relativeDynamicConfigPath;\n  } else if (projectConfig.staticConfigPath) {\n    return path.relative(projectRoot, projectConfig.staticConfigPath);\n  }\n  // If a config doesn't exist, our tooling will generate a static app.json\n  return 'app.json';\n}\n\nexport * from './Config.types';\n\nexport { isLegacyImportsEnabled } from './isLegacyImportsEnabled';\n"]},"metadata":{},"sourceType":"script"}