{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.configureEasBuildAsync = configureEasBuildAsync;\nexports.getEasBuildGradlePath = getEasBuildGradlePath;\nexports.isEasBuildGradleConfiguredAsync = isEasBuildGradleConfiguredAsync;\nfunction _fs() {\n  var data = _interopRequireDefault(require(\"fs\"));\n  _fs = function _fs() {\n    return data;\n  };\n  return data;\n}\nfunction _path() {\n  var data = _interopRequireDefault(require(\"path\"));\n  _path = function _path() {\n    return data;\n  };\n  return data;\n}\nfunction _EasBuildGradleScript() {\n  var data = _interopRequireDefault(require(\"./EasBuildGradleScript\"));\n  _EasBuildGradleScript = function _EasBuildGradleScript() {\n    return data;\n  };\n  return data;\n}\nfunction Paths() {\n  var data = _interopRequireWildcard(require(\"./Paths\"));\n  Paths = function Paths() {\n    return data;\n  };\n  return data;\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar APPLY_EAS_GRADLE = 'apply from: \"./eas-build.gradle\"';\nfunction hasApplyLine(content, applyLine) {\n  return content.replace(/\\r\\n/g, '\\n').split('\\n').some(function (line) {\n    return line === applyLine || line === applyLine.replace(/\"/g, \"'\");\n  });\n}\nfunction getEasBuildGradlePath(projectRoot) {\n  return _path().default.join(projectRoot, 'android', 'app', 'eas-build.gradle');\n}\nfunction configureEasBuildAsync(_x) {\n  return _configureEasBuildAsync.apply(this, arguments);\n}\nfunction _configureEasBuildAsync() {\n  _configureEasBuildAsync = _asyncToGenerator(function* (projectRoot) {\n    var buildGradlePath = Paths().getAppBuildGradleFilePath(projectRoot);\n    var easGradlePath = getEasBuildGradlePath(projectRoot);\n    yield _fs().default.promises.writeFile(easGradlePath, _EasBuildGradleScript().default);\n    var buildGradleContent = yield _fs().default.promises.readFile(_path().default.join(buildGradlePath), 'utf8');\n    var hasEasGradleApply = hasApplyLine(buildGradleContent, APPLY_EAS_GRADLE);\n    if (!hasEasGradleApply) {\n      yield _fs().default.promises.writeFile(buildGradlePath, buildGradleContent.trim() + \"\\n\" + APPLY_EAS_GRADLE + \"\\n\");\n    }\n  });\n  return _configureEasBuildAsync.apply(this, arguments);\n}\nfunction isEasBuildGradleConfiguredAsync(_x2) {\n  return _isEasBuildGradleConfiguredAsync.apply(this, arguments);\n}\nfunction _isEasBuildGradleConfiguredAsync() {\n  _isEasBuildGradleConfiguredAsync = _asyncToGenerator(function* (projectRoot) {\n    var buildGradlePath = Paths().getAppBuildGradleFilePath(projectRoot);\n    var easGradlePath = getEasBuildGradlePath(projectRoot);\n    var hasEasGradleFile = yield _fs().default.existsSync(easGradlePath);\n    var buildGradleContent = yield _fs().default.promises.readFile(_path().default.join(buildGradlePath), 'utf8');\n    var hasEasGradleApply = hasApplyLine(buildGradleContent, APPLY_EAS_GRADLE);\n    return hasEasGradleApply && hasEasGradleFile;\n  });\n  return _isEasBuildGradleConfiguredAsync.apply(this, arguments);\n}","map":{"version":3,"sources":["../../src/android/EasBuild.ts"],"names":["APPLY_EAS_GRADLE","hasApplyLine","content","applyLine","replace","split","some","line","getEasBuildGradlePath","projectRoot","path","join","configureEasBuildAsync","buildGradlePath","Paths","getAppBuildGradleFilePath","easGradlePath","fs","promises","writeFile","gradleScript","buildGradleContent","readFile","hasEasGradleApply","trim","isEasBuildGradleConfiguredAsync","hasEasGradleFile","existsSync"],"mappings":"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","sourcesContent":["import fs from 'fs';\nimport path from 'path';\n\nimport gradleScript from './EasBuildGradleScript';\nimport * as Paths from './Paths';\n\nconst APPLY_EAS_GRADLE = 'apply from: \"./eas-build.gradle\"';\n\nfunction hasApplyLine(content: string, applyLine: string): boolean {\n  return (\n    content\n      .replace(/\\r\\n/g, '\\n')\n      .split('\\n')\n      // Check for both single and double quotes\n      .some((line) => line === applyLine || line === applyLine.replace(/\"/g, \"'\"))\n  );\n}\n\nexport function getEasBuildGradlePath(projectRoot: string): string {\n  return path.join(projectRoot, 'android', 'app', 'eas-build.gradle');\n}\n\nexport async function configureEasBuildAsync(projectRoot: string): Promise<void> {\n  const buildGradlePath = Paths.getAppBuildGradleFilePath(projectRoot);\n  const easGradlePath = getEasBuildGradlePath(projectRoot);\n\n  await fs.promises.writeFile(easGradlePath, gradleScript);\n\n  const buildGradleContent = await fs.promises.readFile(path.join(buildGradlePath), 'utf8');\n\n  const hasEasGradleApply = hasApplyLine(buildGradleContent, APPLY_EAS_GRADLE);\n\n  if (!hasEasGradleApply) {\n    await fs.promises.writeFile(\n      buildGradlePath,\n      `${buildGradleContent.trim()}\\n${APPLY_EAS_GRADLE}\\n`\n    );\n  }\n}\n\nexport async function isEasBuildGradleConfiguredAsync(projectRoot: string): Promise<boolean> {\n  const buildGradlePath = Paths.getAppBuildGradleFilePath(projectRoot);\n  const easGradlePath = getEasBuildGradlePath(projectRoot);\n\n  const hasEasGradleFile = await fs.existsSync(easGradlePath);\n\n  const buildGradleContent = await fs.promises.readFile(path.join(buildGradlePath), 'utf8');\n  const hasEasGradleApply = hasApplyLine(buildGradleContent, APPLY_EAS_GRADLE);\n\n  return hasEasGradleApply && hasEasGradleFile;\n}\n"]},"metadata":{},"sourceType":"script"}