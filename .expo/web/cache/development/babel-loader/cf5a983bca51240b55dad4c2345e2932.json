{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getApplicationTargetNameForSchemeAsync = getApplicationTargetNameForSchemeAsync;\nexports.getArchiveBuildConfigurationForSchemeAsync = getArchiveBuildConfigurationForSchemeAsync;\nexports.getRunnableSchemesFromXcodeproj = getRunnableSchemesFromXcodeproj;\nexports.getSchemesFromXcodeproj = getSchemesFromXcodeproj;\nfunction _XML() {\n  var data = require(\"../utils/XML\");\n  _XML = function _XML() {\n    return data;\n  };\n  return data;\n}\nfunction _Paths() {\n  var data = require(\"./Paths\");\n  _Paths = function _Paths() {\n    return data;\n  };\n  return data;\n}\nfunction _Target() {\n  var data = require(\"./Target\");\n  _Target = function _Target() {\n    return data;\n  };\n  return data;\n}\nfunction _Xcodeproj() {\n  var data = require(\"./utils/Xcodeproj\");\n  _Xcodeproj = function _Xcodeproj() {\n    return data;\n  };\n  return data;\n}\nfunction getSchemesFromXcodeproj(projectRoot) {\n  return (0, _Paths().findSchemeNames)(projectRoot);\n}\nfunction getRunnableSchemesFromXcodeproj(projectRoot) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$configuration = _ref.configuration,\n    configuration = _ref$configuration === void 0 ? 'Debug' : _ref$configuration;\n  var project = (0, _Xcodeproj().getPbxproj)(projectRoot);\n  return (0, _Target().findSignableTargets)(project).map(function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n      target = _ref3[1];\n    var osType = 'iOS';\n    var type = (0, _Xcodeproj().unquote)(target.productType);\n    if (type === _Target().TargetType.WATCH) {\n      osType = 'watchOS';\n    } else if (type.startsWith(_Target().TargetType.APPLICATION)) {\n      var xcConfigurationList = project.hash.project.objects.XCConfigurationList[target.buildConfigurationList];\n      if (xcConfigurationList) {\n        var buildConfiguration = xcConfigurationList.buildConfigurations.find(function (value) {\n          return value.comment === configuration;\n        }) || xcConfigurationList.buildConfigurations[0];\n        if (buildConfiguration !== null && buildConfiguration !== void 0 && buildConfiguration.value) {\n          var _project$hash$project;\n          var xcBuildConfiguration = (_project$hash$project = project.hash.project.objects.XCBuildConfiguration) === null || _project$hash$project === void 0 ? void 0 : _project$hash$project[buildConfiguration.value];\n          var buildSdkRoot = xcBuildConfiguration.buildSettings.SDKROOT;\n          if (buildSdkRoot === 'appletvos' || 'TVOS_DEPLOYMENT_TARGET' in xcBuildConfiguration.buildSettings) {\n            osType = 'tvOS';\n          } else if (buildSdkRoot === 'iphoneos') {\n            osType = 'iOS';\n          }\n        }\n      }\n    }\n    return {\n      name: (0, _Xcodeproj().unquote)(target.name),\n      osType: osType,\n      type: (0, _Xcodeproj().unquote)(target.productType)\n    };\n  });\n}\nfunction readSchemeAsync(_x, _x2) {\n  return _readSchemeAsync.apply(this, arguments);\n}\nfunction _readSchemeAsync() {\n  _readSchemeAsync = _asyncToGenerator(function* (projectRoot, scheme) {\n    var allSchemePaths = (0, _Paths().findSchemePaths)(projectRoot);\n    var re = new RegExp(\"/\" + scheme + \".xcscheme\", 'i');\n    var schemePath = allSchemePaths.find(function (i) {\n      return re.exec(i);\n    });\n    if (schemePath) {\n      return yield (0, _XML().readXMLAsync)({\n        path: schemePath\n      });\n    } else {\n      throw new Error(\"scheme '\" + scheme + \"' does not exist, make sure it's marked as shared\");\n    }\n  });\n  return _readSchemeAsync.apply(this, arguments);\n}\nfunction getApplicationTargetNameForSchemeAsync(_x3, _x4) {\n  return _getApplicationTargetNameForSchemeAsync.apply(this, arguments);\n}\nfunction _getApplicationTargetNameForSchemeAsync() {\n  _getApplicationTargetNameForSchemeAsync = _asyncToGenerator(function* (projectRoot, scheme) {\n    var _schemeXML$Scheme, _schemeXML$Scheme$Bui, _schemeXML$Scheme$Bui2, _schemeXML$Scheme$Bui3, _schemeXML$Scheme$Bui4;\n    var schemeXML = yield readSchemeAsync(projectRoot, scheme);\n    var buildActionEntry = schemeXML === null || schemeXML === void 0 ? void 0 : (_schemeXML$Scheme = schemeXML.Scheme) === null || _schemeXML$Scheme === void 0 ? void 0 : (_schemeXML$Scheme$Bui = _schemeXML$Scheme.BuildAction) === null || _schemeXML$Scheme$Bui === void 0 ? void 0 : (_schemeXML$Scheme$Bui2 = _schemeXML$Scheme$Bui[0]) === null || _schemeXML$Scheme$Bui2 === void 0 ? void 0 : (_schemeXML$Scheme$Bui3 = _schemeXML$Scheme$Bui2.BuildActionEntries) === null || _schemeXML$Scheme$Bui3 === void 0 ? void 0 : (_schemeXML$Scheme$Bui4 = _schemeXML$Scheme$Bui3[0]) === null || _schemeXML$Scheme$Bui4 === void 0 ? void 0 : _schemeXML$Scheme$Bui4.BuildActionEntry;\n    var targetName = (buildActionEntry === null || buildActionEntry === void 0 ? void 0 : buildActionEntry.length) === 1 ? getBlueprintName(buildActionEntry[0]) : getBlueprintName(buildActionEntry === null || buildActionEntry === void 0 ? void 0 : buildActionEntry.find(function (entry) {\n      var _entry$BuildableRefer, _entry$BuildableRefer2, _entry$BuildableRefer3, _entry$BuildableRefer4;\n      return (_entry$BuildableRefer = entry.BuildableReference) === null || _entry$BuildableRefer === void 0 ? void 0 : (_entry$BuildableRefer2 = _entry$BuildableRefer[0]) === null || _entry$BuildableRefer2 === void 0 ? void 0 : (_entry$BuildableRefer3 = _entry$BuildableRefer2['$']) === null || _entry$BuildableRefer3 === void 0 ? void 0 : (_entry$BuildableRefer4 = _entry$BuildableRefer3.BuildableName) === null || _entry$BuildableRefer4 === void 0 ? void 0 : _entry$BuildableRefer4.endsWith('.app');\n    }));\n    if (!targetName) {\n      throw new Error(scheme + \".xcscheme seems to be corrupted\");\n    }\n    return targetName;\n  });\n  return _getApplicationTargetNameForSchemeAsync.apply(this, arguments);\n}\nfunction getArchiveBuildConfigurationForSchemeAsync(_x5, _x6) {\n  return _getArchiveBuildConfigurationForSchemeAsync.apply(this, arguments);\n}\nfunction _getArchiveBuildConfigurationForSchemeAsync() {\n  _getArchiveBuildConfigurationForSchemeAsync = _asyncToGenerator(function* (projectRoot, scheme) {\n    var _schemeXML$Scheme2, _schemeXML$Scheme2$Ar, _schemeXML$Scheme2$Ar2, _schemeXML$Scheme2$Ar3;\n    var schemeXML = yield readSchemeAsync(projectRoot, scheme);\n    var buildConfiguration = schemeXML === null || schemeXML === void 0 ? void 0 : (_schemeXML$Scheme2 = schemeXML.Scheme) === null || _schemeXML$Scheme2 === void 0 ? void 0 : (_schemeXML$Scheme2$Ar = _schemeXML$Scheme2.ArchiveAction) === null || _schemeXML$Scheme2$Ar === void 0 ? void 0 : (_schemeXML$Scheme2$Ar2 = _schemeXML$Scheme2$Ar[0]) === null || _schemeXML$Scheme2$Ar2 === void 0 ? void 0 : (_schemeXML$Scheme2$Ar3 = _schemeXML$Scheme2$Ar2['$']) === null || _schemeXML$Scheme2$Ar3 === void 0 ? void 0 : _schemeXML$Scheme2$Ar3.buildConfiguration;\n    if (!buildConfiguration) {\n      throw new Error(scheme + \".xcscheme seems to be corrupted\");\n    }\n    return buildConfiguration;\n  });\n  return _getArchiveBuildConfigurationForSchemeAsync.apply(this, arguments);\n}\nfunction getBlueprintName(entry) {\n  var _entry$BuildableRefer5, _entry$BuildableRefer6, _entry$BuildableRefer7;\n  return entry === null || entry === void 0 ? void 0 : (_entry$BuildableRefer5 = entry.BuildableReference) === null || _entry$BuildableRefer5 === void 0 ? void 0 : (_entry$BuildableRefer6 = _entry$BuildableRefer5[0]) === null || _entry$BuildableRefer6 === void 0 ? void 0 : (_entry$BuildableRefer7 = _entry$BuildableRefer6['$']) === null || _entry$BuildableRefer7 === void 0 ? void 0 : _entry$BuildableRefer7.BlueprintName;\n}","map":{"version":3,"sources":["../../src/ios/BuildScheme.ts"],"names":["getSchemesFromXcodeproj","projectRoot","getRunnableSchemesFromXcodeproj","configuration","project","map","target","osType","type","productType","TargetType","WATCH","startsWith","APPLICATION","xcConfigurationList","hash","objects","XCConfigurationList","buildConfigurationList","buildConfiguration","buildConfigurations","find","value","comment","xcBuildConfiguration","XCBuildConfiguration","buildSdkRoot","buildSettings","SDKROOT","name","readSchemeAsync","scheme","allSchemePaths","re","RegExp","schemePath","i","exec","path","Error","getApplicationTargetNameForSchemeAsync","schemeXML","buildActionEntry","Scheme","BuildAction","BuildActionEntries","BuildActionEntry","targetName","length","getBlueprintName","entry","BuildableReference","BuildableName","endsWith","getArchiveBuildConfigurationForSchemeAsync","ArchiveAction","BlueprintName"],"mappings":"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","sourcesContent":["import { readXMLAsync } from '../utils/XML';\nimport { findSchemeNames, findSchemePaths } from './Paths';\nimport { findSignableTargets, TargetType } from './Target';\nimport { getPbxproj, unquote } from './utils/Xcodeproj';\n\ninterface SchemeXML {\n  Scheme?: {\n    BuildAction?: {\n      BuildActionEntries?: {\n        BuildActionEntry?: BuildActionEntryType[];\n      }[];\n    }[];\n    ArchiveAction?: {\n      $?: {\n        buildConfiguration?: string;\n      };\n    }[];\n  };\n}\n\ninterface BuildActionEntryType {\n  BuildableReference?: {\n    $?: {\n      BlueprintName?: string;\n      BuildableName?: string;\n    };\n  }[];\n}\n\nexport function getSchemesFromXcodeproj(projectRoot: string): string[] {\n  return findSchemeNames(projectRoot);\n}\n\nexport function getRunnableSchemesFromXcodeproj(\n  projectRoot: string,\n  { configuration = 'Debug' }: { configuration?: 'Debug' | 'Release' } = {}\n): { name: string; osType: string; type: string }[] {\n  const project = getPbxproj(projectRoot);\n\n  return findSignableTargets(project).map(([, target]) => {\n    let osType = 'iOS';\n    const type = unquote(target.productType);\n\n    if (type === TargetType.WATCH) {\n      osType = 'watchOS';\n    } else if (\n      // (apps) com.apple.product-type.application\n      // (app clips) com.apple.product-type.application.on-demand-install-capable\n      // NOTE(EvanBacon): This matches against `watchOS` as well so we check for watch first.\n      type.startsWith(TargetType.APPLICATION)\n    ) {\n      // Attempt to resolve the platform SDK for each target so we can filter devices.\n      const xcConfigurationList =\n        project.hash.project.objects.XCConfigurationList[target.buildConfigurationList];\n\n      if (xcConfigurationList) {\n        const buildConfiguration =\n          xcConfigurationList.buildConfigurations.find(\n            (value: { comment: string; value: string }) => value.comment === configuration\n          ) || xcConfigurationList.buildConfigurations[0];\n        if (buildConfiguration?.value) {\n          const xcBuildConfiguration =\n            project.hash.project.objects.XCBuildConfiguration?.[buildConfiguration.value];\n\n          const buildSdkRoot = xcBuildConfiguration.buildSettings.SDKROOT;\n          if (\n            buildSdkRoot === 'appletvos' ||\n            'TVOS_DEPLOYMENT_TARGET' in xcBuildConfiguration.buildSettings\n          ) {\n            // Is a TV app...\n            osType = 'tvOS';\n          } else if (buildSdkRoot === 'iphoneos') {\n            osType = 'iOS';\n          }\n        }\n      }\n    }\n\n    return {\n      name: unquote(target.name),\n      osType,\n      type: unquote(target.productType),\n    };\n  });\n}\n\nasync function readSchemeAsync(\n  projectRoot: string,\n  scheme: string\n): Promise<SchemeXML | undefined> {\n  const allSchemePaths = findSchemePaths(projectRoot);\n  const re = new RegExp(`/${scheme}.xcscheme`, 'i');\n  const schemePath = allSchemePaths.find((i) => re.exec(i));\n  if (schemePath) {\n    return (await readXMLAsync({ path: schemePath })) as unknown as SchemeXML | undefined;\n  } else {\n    throw new Error(`scheme '${scheme}' does not exist, make sure it's marked as shared`);\n  }\n}\n\nexport async function getApplicationTargetNameForSchemeAsync(\n  projectRoot: string,\n  scheme: string\n): Promise<string> {\n  const schemeXML = await readSchemeAsync(projectRoot, scheme);\n  const buildActionEntry =\n    schemeXML?.Scheme?.BuildAction?.[0]?.BuildActionEntries?.[0]?.BuildActionEntry;\n  const targetName =\n    buildActionEntry?.length === 1\n      ? getBlueprintName(buildActionEntry[0])\n      : getBlueprintName(\n          buildActionEntry?.find((entry) => {\n            return entry.BuildableReference?.[0]?.['$']?.BuildableName?.endsWith('.app');\n          })\n        );\n  if (!targetName) {\n    throw new Error(`${scheme}.xcscheme seems to be corrupted`);\n  }\n  return targetName;\n}\n\nexport async function getArchiveBuildConfigurationForSchemeAsync(\n  projectRoot: string,\n  scheme: string\n): Promise<string> {\n  const schemeXML = await readSchemeAsync(projectRoot, scheme);\n  const buildConfiguration = schemeXML?.Scheme?.ArchiveAction?.[0]?.['$']?.buildConfiguration;\n  if (!buildConfiguration) {\n    throw new Error(`${scheme}.xcscheme seems to be corrupted`);\n  }\n  return buildConfiguration;\n}\n\nfunction getBlueprintName(entry?: BuildActionEntryType): string | undefined {\n  return entry?.BuildableReference?.[0]?.['$']?.BlueprintName;\n}\n"]},"metadata":{},"sourceType":"script"}