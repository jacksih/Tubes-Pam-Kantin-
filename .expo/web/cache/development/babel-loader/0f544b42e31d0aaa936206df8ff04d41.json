{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteralLoose = require(\"@babel/runtime/helpers/taggedTemplateLiteralLoose\");\nvar _templateObject;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createMultiRuleTransformer = createMultiRuleTransformer;\nexports.loaders = void 0;\nfunction _chalk() {\n  var data = _interopRequireDefault(require(\"chalk\"));\n  _chalk = function _chalk() {\n    return data;\n  };\n  return data;\n}\nfunction _debug() {\n  var data = _interopRequireDefault(require(\"debug\"));\n  _debug = function _debug() {\n    return data;\n  };\n  return data;\n}\nfunction _resolveFrom() {\n  var data = _interopRequireDefault(require(\"resolve-from\"));\n  _resolveFrom = function _resolveFrom() {\n    return data;\n  };\n  return data;\n}\nfunction _generateFunctionMap() {\n  var data = require(\"./generateFunctionMap\");\n  _generateFunctionMap = function _generateFunctionMap() {\n    return data;\n  };\n  return data;\n}\nfunction _getBabelConfig() {\n  var data = require(\"./getBabelConfig\");\n  _getBabelConfig = function _getBabelConfig() {\n    return data;\n  };\n  return data;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar debug = (0, _debug().default)('expo:metro:exotic-babel-transformer');\nvar babelCore;\nfunction getBabelCoreFromProject(projectRoot) {\n  if (babelCore) return babelCore;\n  babelCore = require((0, _resolveFrom().default)(projectRoot, '@babel/core'));\n  return babelCore;\n}\nvar babelParser;\nfunction getBabelParserFromProject(projectRoot) {\n  if (babelParser) return babelParser;\n  babelParser = require((0, _resolveFrom().default)(projectRoot, '@babel/parser'));\n  return babelParser;\n}\nfunction sucrase(args, _ref) {\n  var transforms = _ref.transforms;\n  var src = args.src,\n    filename = args.filename,\n    dev = args.options.dev;\n  var _require = require('sucrase'),\n    transform = _require.transform;\n  var results = transform(src, {\n    filePath: filename,\n    production: !dev,\n    transforms: transforms\n  });\n  return {\n    code: results.code,\n    functionMap: null\n  };\n}\nvar getExpensiveSucraseTransforms = function getExpensiveSucraseTransforms(filename) {\n  return ['jsx', 'imports', /\\.tsx?$/.test(filename) ? 'typescript' : 'flow'];\n};\nfunction parseAst(projectRoot, sourceCode) {\n  var babylon = getBabelParserFromProject(projectRoot);\n  return babylon.parse(sourceCode, {\n    sourceType: 'unambiguous'\n  });\n}\nfunction createMultiRuleTransformer(_ref2) {\n  var getRuleType = _ref2.getRuleType,\n    rules = _ref2.rules;\n  return function transform(args) {\n    var filename = args.filename,\n      options = args.options;\n    var OLD_BABEL_ENV = process.env.BABEL_ENV;\n    process.env.BABEL_ENV = options !== null && options !== void 0 && options.dev ? 'development' : process.env.BABEL_ENV || 'production';\n    try {\n      var ruleType = getRuleType(args);\n      for (var rule of rules) {\n        if (rule.type && rule.type !== ruleType) {\n          continue;\n        }\n        var isMatched = typeof rule.test === 'function' ? rule.test(args) : rule.test.test(args.filename);\n        if (isMatched) {\n          var results = rule.transform(args);\n          results._ruleName = rule.name;\n          if (results.code && !results.ast) {\n            results.ast = parseAst(options === null || options === void 0 ? void 0 : options.projectRoot, results.code);\n          }\n          return results;\n        }\n      }\n      throw new Error('no loader rule to handle file: ' + filename);\n    } finally {\n      if (OLD_BABEL_ENV) {\n        process.env.BABEL_ENV = OLD_BABEL_ENV;\n      }\n    }\n  };\n}\nvar loaders = {\n  app: function app(args) {\n    debug('app:', args.filename);\n    var filename = args.filename,\n      options = args.options,\n      src = args.src,\n      plugins = args.plugins;\n    var babelConfig = Object.assign({\n      sourceType: 'unambiguous'\n    }, (0, _getBabelConfig().getBabelConfig)(filename, options, plugins), {\n      caller: {\n        name: 'metro',\n        platform: options.platform\n      },\n      ast: true\n    });\n    Object.defineProperty(babelConfig.caller, 'onWarning', {\n      enumerable: false,\n      writable: false,\n      value: babelConfig.caller.onWarning = function (msg) {\n        console.warn(_chalk().default.bold.yellow(_templateObject || (_templateObject = _taggedTemplateLiteralLoose([\"warn \"]))) + args.filename);\n        console.warn(msg);\n      }\n    });\n    var _getBabelCoreFromProj = getBabelCoreFromProject(options.projectRoot),\n      parseSync = _getBabelCoreFromProj.parseSync,\n      transformFromAstSync = _getBabelCoreFromProj.transformFromAstSync;\n    var sourceAst = parseSync(src, babelConfig);\n    if (!sourceAst) return {\n      ast: null\n    };\n    var result = transformFromAstSync(sourceAst, src, babelConfig);\n    var functionMap = (0, _generateFunctionMap().generateFunctionMap)(options.projectRoot, sourceAst, {\n      filename: filename\n    });\n    if (!result) {\n      return {\n        ast: null,\n        functionMap: functionMap\n      };\n    }\n    return {\n      ast: result.ast,\n      functionMap: functionMap\n    };\n  },\n  reactNativeModule: function reactNativeModule(args) {\n    debug('rn:', args.filename);\n    return sucrase(args, {\n      transforms: ['jsx', 'flow', 'imports']\n    });\n  },\n  expoModule: function expoModule(args) {\n    debug('expo:', args.filename);\n    return sucrase(args, {\n      transforms: ['imports', /(expo-processing|expo\\/vector-icons)/.test(args.filename) && 'jsx', /(expo-asset-utils)/.test(args.filename) && 'flow'].filter(Boolean)\n    });\n  },\n  untranspiledModule: function untranspiledModule(args) {\n    debug('known issues:', args.filename);\n    return sucrase(args, {\n      transforms: getExpensiveSucraseTransforms(args.filename)\n    });\n  },\n  passthroughModule: function passthroughModule(args) {\n    var filename = args.filename,\n      options = args.options,\n      src = args.src;\n    debug('passthrough:', filename);\n    var ast = parseAst(options.projectRoot, src);\n    var functionMap = (0, _generateFunctionMap().generateFunctionMap)(options.projectRoot, ast, {\n      filename: filename\n    });\n    return {\n      code: src,\n      functionMap: functionMap,\n      ast: ast\n    };\n  }\n};\nexports.loaders = loaders;","map":{"version":3,"sources":["../../src/transformer/createMultiRuleTransformer.ts"],"names":["debug","babelCore","getBabelCoreFromProject","projectRoot","require","babelParser","getBabelParserFromProject","sucrase","args","transforms","src","filename","options","dev","transform","results","filePath","production","code","functionMap","getExpensiveSucraseTransforms","test","parseAst","sourceCode","babylon","parse","sourceType","createMultiRuleTransformer","getRuleType","rules","OLD_BABEL_ENV","process","env","BABEL_ENV","ruleType","rule","type","isMatched","_ruleName","name","ast","Error","loaders","app","plugins","babelConfig","caller","platform","Object","defineProperty","enumerable","writable","value","onWarning","msg","console","warn","chalk","bold","yellow","parseSync","transformFromAstSync","sourceAst","result","reactNativeModule","expoModule","filter","Boolean","untranspiledModule","passthroughModule"],"mappings":"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","sourcesContent":["// Copyright 2021-present 650 Industries (Expo). All rights reserved.\n\nimport chalk from 'chalk';\nimport Debug from 'debug';\nimport type { BabelTransformer, BabelTransformerArgs } from 'metro-babel-transformer';\nimport resolveFrom from 'resolve-from';\n\nimport { generateFunctionMap } from './generateFunctionMap';\nimport { getBabelConfig } from './getBabelConfig';\n\nconst debug = Debug('expo:metro:exotic-babel-transformer');\n\nlet babelCore: typeof import('@babel/core') | undefined;\n\nfunction getBabelCoreFromProject(projectRoot: string) {\n  if (babelCore) return babelCore;\n  babelCore = require(resolveFrom(projectRoot, '@babel/core'));\n  return babelCore!;\n}\n\nlet babelParser: typeof import('@babel/parser') | undefined;\n\nfunction getBabelParserFromProject(projectRoot: string) {\n  if (babelParser) return babelParser;\n  babelParser = require(resolveFrom(projectRoot, '@babel/parser'));\n  return babelParser!;\n}\n\nfunction sucrase(\n  args: BabelTransformerArgs,\n  {\n    transforms,\n  }: {\n    transforms: string[];\n  }\n): Partial<ReturnType<BabelTransformer['transform']>> {\n  const {\n    src,\n    filename,\n    options: { dev },\n  } = args;\n  const { transform } = require('sucrase');\n\n  const results = transform(src, {\n    filePath: filename,\n    production: !dev,\n    transforms,\n  });\n\n  return {\n    code: results.code,\n    functionMap: null,\n  };\n}\n\nconst getExpensiveSucraseTransforms = (filename: string) => [\n  'jsx',\n  'imports',\n  /\\.tsx?$/.test(filename) ? 'typescript' : 'flow',\n];\n\nfunction parseAst(projectRoot: string, sourceCode: string) {\n  const babylon = getBabelParserFromProject(projectRoot);\n\n  return babylon.parse(sourceCode, {\n    sourceType: 'unambiguous',\n  });\n}\n\nexport type Rule = {\n  warn?: boolean;\n  type?: 'module' | 'app';\n  name?: string;\n  test: ((args: BabelTransformerArgs) => boolean) | RegExp;\n  transform: BabelTransformer['transform'];\n};\n\n/** Create a transformer that emulates Webpack's loader system. */\nexport function createMultiRuleTransformer({\n  getRuleType,\n  rules,\n}: {\n  getRuleType: (args: BabelTransformerArgs) => string;\n  rules: Rule[];\n}): BabelTransformer['transform'] {\n  // const warnings: string[] = [];\n  return function transform(args: BabelTransformerArgs) {\n    const { filename, options } = args;\n    const OLD_BABEL_ENV = process.env.BABEL_ENV;\n    process.env.BABEL_ENV = options?.dev ? 'development' : process.env.BABEL_ENV || 'production';\n\n    try {\n      const ruleType = getRuleType(args);\n\n      for (const rule of rules) {\n        // optimization for checking node modules\n        if (rule.type && rule.type !== ruleType) {\n          continue;\n        }\n\n        const isMatched =\n          typeof rule.test === 'function' ? rule.test(args) : rule.test.test(args.filename);\n        if (isMatched) {\n          const results = rule.transform(args);\n          // @ts-ignore: Add extra property for testing\n          results._ruleName = rule.name;\n          // Perform a basic parse if none exists, this enables us to control the output, but only if it changed.\n          if (results.code && !results.ast) {\n            // Parse AST with babel otherwise Metro transformer will throw away the returned results.\n            results.ast = parseAst(options?.projectRoot, results.code);\n          }\n\n          // TODO: Suboptimal warnings\n          // if (rule.warn) {\n          //   const matchName =\n          //     filename.match(/node_modules\\/((:?@[\\w\\d-]+\\/[\\w\\d-]+)|(:?[\\w\\d-]+))\\/?/)?.[1] ??\n          //     filename;\n          //   if (matchName && !warnings.includes(matchName)) {\n          //     warnings.push(matchName);\n          //     console.warn(chalk.yellow.bold`warn `, matchName);\n          //     console.warn(\n          //       chalk.yellow`untranspiled module is potentially causing bundler slowdown, using modules that support commonjs will make your dev server much faster.`\n          //     );\n          //   }\n          // }\n\n          return results;\n        }\n      }\n      throw new Error('no loader rule to handle file: ' + filename);\n    } finally {\n      if (OLD_BABEL_ENV) {\n        process.env.BABEL_ENV = OLD_BABEL_ENV;\n      }\n    }\n  };\n}\n\nexport const loaders: Record<string, (args: BabelTransformerArgs) => any> = {\n  // Perform the standard, and most expensive transpilation sequence.\n  app(args) {\n    debug('app:', args.filename);\n\n    const { filename, options, src, plugins } = args;\n    const babelConfig = {\n      // ES modules require sourceType='module' but OSS may not always want that\n      sourceType: 'unambiguous',\n      ...getBabelConfig(filename, options, plugins),\n      // Variables that are exposed to the user's babel preset.\n      caller: {\n        name: 'metro',\n\n        platform: options.platform,\n      },\n      ast: true,\n    };\n\n    // Surface a warning function so babel linters can be used.\n    Object.defineProperty(babelConfig.caller, 'onWarning', {\n      enumerable: false,\n      writable: false,\n      value: (babelConfig.caller.onWarning = function (msg: any) {\n        // Format the file path first so users know where the warning came from.\n        console.warn(chalk.bold.yellow`warn ` + args.filename);\n        console.warn(msg);\n      }),\n    });\n\n    const { parseSync, transformFromAstSync } = getBabelCoreFromProject(options.projectRoot);\n    const sourceAst = parseSync(src, babelConfig);\n\n    // Should never happen.\n    if (!sourceAst) return { ast: null };\n\n    const result = transformFromAstSync(sourceAst, src, babelConfig);\n\n    // TODO: Disable by default\n    const functionMap = generateFunctionMap(options.projectRoot, sourceAst, { filename });\n    // The result from `transformFromAstSync` can be null (if the file is ignored)\n    if (!result) {\n      return { ast: null, functionMap };\n    }\n\n    return { ast: result.ast, functionMap };\n  },\n\n  // Transpile react-native with sucrase.\n  reactNativeModule(args) {\n    debug('rn:', args.filename);\n    return sucrase(args, {\n      transforms: ['jsx', 'flow', 'imports'],\n    });\n  },\n\n  // Transpile expo modules with sucrase.\n  expoModule(args) {\n    debug('expo:', args.filename);\n    // TODO: Fix all expo packages\n    return sucrase(args, {\n      transforms: [\n        'imports',\n        // TODO: fix expo-processing, expo/vector-icons\n        /(expo-processing|expo\\/vector-icons)/.test(args.filename) && 'jsx',\n        // TODO: fix expo-asset-utils\n        /(expo-asset-utils)/.test(args.filename) && 'flow',\n      ].filter(Boolean) as string[],\n    });\n  },\n\n  // Transpile known community modules with the most expensive sucrase\n  untranspiledModule(args) {\n    debug('known issues:', args.filename);\n    return sucrase(args, {\n      transforms: getExpensiveSucraseTransforms(args.filename),\n    });\n  },\n\n  // Pass all modules through without transpiling them.\n  passthroughModule(args) {\n    const { filename, options, src } = args;\n    debug('passthrough:', filename);\n\n    // Perform a basic ast parse, this doesn't matter since the worker will parse and ignore anyways.\n    const ast = parseAst(options.projectRoot, src);\n\n    // TODO: Disable by default\n    const functionMap = generateFunctionMap(options.projectRoot, ast, { filename });\n\n    return {\n      code: src,\n      functionMap,\n      ast,\n    };\n  },\n};\n"]},"metadata":{},"sourceType":"script"}