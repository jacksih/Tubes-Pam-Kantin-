{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar _excluded = [\"modRequest\"],\n  _excluded2 = [\"nextMod\"],\n  _excluded3 = [\"modRequest\", \"modResults\"];\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withBaseMod = withBaseMod;\nexports.withMod = withMod;\nfunction _chalk() {\n  var data = _interopRequireDefault(require(\"chalk\"));\n  _chalk = function _chalk() {\n    return data;\n  };\n  return data;\n}\nfunction _getenv() {\n  var data = require(\"getenv\");\n  _getenv = function _getenv() {\n    return data;\n  };\n  return data;\n}\nfunction _errors() {\n  var data = require(\"../utils/errors\");\n  _errors = function _errors() {\n    return data;\n  };\n  return data;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar EXPO_DEBUG = (0, _getenv().boolish)('EXPO_DEBUG', false);\nfunction withBaseMod(config, _ref2) {\n  var platform = _ref2.platform,\n    mod = _ref2.mod,\n    action = _ref2.action,\n    skipEmptyMod = _ref2.skipEmptyMod,\n    isProvider = _ref2.isProvider,\n    isIntrospective = _ref2.isIntrospective,\n    saveToInternal = _ref2.saveToInternal;\n  var _config$_internal$isD, _config$_internal;\n  if (!config.mods) {\n    config.mods = {};\n  }\n  if (!config.mods[platform]) {\n    config.mods[platform] = {};\n  }\n  var interceptedMod = config.mods[platform][mod];\n  if (!interceptedMod) {\n    if (skipEmptyMod) {\n      return config;\n    }\n    var noopMod = function noopMod(config) {\n      return config;\n    };\n    interceptedMod = noopMod;\n  }\n  var debugTrace = '';\n  var isDebug = (_config$_internal$isD = (_config$_internal = config._internal) === null || _config$_internal === void 0 ? void 0 : _config$_internal.isDebug) !== null && _config$_internal$isD !== void 0 ? _config$_internal$isD : EXPO_DEBUG;\n  if (isDebug) {\n    var stack = new Error().stack;\n    debugTrace = getDebugPluginStackFromStackTrace(stack);\n    var modStack = _chalk().default.bold(platform + \".\" + mod);\n    debugTrace = modStack + \": \" + debugTrace;\n  }\n  if (interceptedMod.isProvider) {\n    if (isProvider) {\n      throw new (_errors().PluginError)(\"Cannot set provider mod for \\\"\" + platform + \".\" + mod + \"\\\" because another is already being used.\", 'CONFLICTING_PROVIDER');\n    } else {\n      throw new (_errors().PluginError)(\"Cannot add mod to \\\"\" + platform + \".\" + mod + \"\\\" because the provider has already been added. Provider must be the last mod added.\", 'INVALID_MOD_ORDER');\n    }\n  }\n  function interceptingMod(_x) {\n    return _interceptingMod.apply(this, arguments);\n  }\n  function _interceptingMod() {\n    _interceptingMod = _asyncToGenerator(function* (_ref3) {\n      var modRequest = _ref3.modRequest,\n        config = _objectWithoutProperties(_ref3, _excluded);\n      if (isDebug) {\n        console.log(debugTrace);\n      }\n      var results = yield action(Object.assign({}, config, {\n        modRequest: Object.assign({}, modRequest, {\n          nextMod: interceptedMod\n        })\n      }));\n      if (saveToInternal) {\n        saveToInternalObject(results, platform, mod, results.modResults);\n      }\n      return results;\n    });\n    return _interceptingMod.apply(this, arguments);\n  }\n  interceptingMod.isProvider = isProvider;\n  if (isIntrospective) {\n    interceptingMod.isIntrospective = isIntrospective;\n  }\n  config.mods[platform][mod] = interceptingMod;\n  return config;\n}\nfunction saveToInternalObject(config, platformName, modName, results) {\n  if (!config._internal) config._internal = {};\n  if (!config._internal.modResults) config._internal.modResults = {};\n  if (!config._internal.modResults[platformName]) config._internal.modResults[platformName] = {};\n  config._internal.modResults[platformName][modName] = results;\n}\nfunction getDebugPluginStackFromStackTrace(stacktrace) {\n  if (!stacktrace) {\n    return '';\n  }\n  var treeStackLines = [];\n  for (var line of stacktrace.split('\\n')) {\n    var _line$trim$split = line.trim().split(' '),\n      _line$trim$split2 = _slicedToArray(_line$trim$split, 2),\n      first = _line$trim$split2[0],\n      second = _line$trim$split2[1];\n    if (first === 'at') {\n      treeStackLines.push(second);\n    }\n  }\n  var plugins = treeStackLines.map(function (first) {\n    var _ref, _first$match$1$trim, _first$match, _first$match$, _first$match2, _first$match2$;\n    return (_ref = (_first$match$1$trim = first === null || first === void 0 ? void 0 : (_first$match = first.match(/^(\\bwith[A-Z].*?\\b)/)) === null || _first$match === void 0 ? void 0 : (_first$match$ = _first$match[1]) === null || _first$match$ === void 0 ? void 0 : _first$match$.trim()) !== null && _first$match$1$trim !== void 0 ? _first$match$1$trim : first === null || first === void 0 ? void 0 : (_first$match2 = first.match(/\\.(\\bwith[A-Z].*?\\b)/)) === null || _first$match2 === void 0 ? void 0 : (_first$match2$ = _first$match2[1]) === null || _first$match2$ === void 0 ? void 0 : _first$match2$.trim()) !== null && _ref !== void 0 ? _ref : null;\n  }).filter(Boolean).filter(function (plugin) {\n    return !['withMod', 'withBaseMod', 'withExtendedMod'].includes(plugin);\n  });\n  var commonPlugins = ['withPlugins', 'withRunOnce', 'withStaticPlugin'];\n  return plugins.reverse().map(function (pluginName, index) {\n    if (pluginName.includes('BaseMod')) {\n      pluginName = _chalk().default.bold(pluginName);\n    }\n    if (pluginName.toLowerCase().includes('dangerous')) {\n      pluginName = _chalk().default.red(pluginName);\n    }\n    if (index === 0) {\n      return _chalk().default.blue(pluginName);\n    } else if (commonPlugins.includes(pluginName)) {\n      return _chalk().default.dim(pluginName);\n    }\n    return pluginName;\n  }).join(' ➜ ');\n}\nfunction withMod(config, _ref4) {\n  var platform = _ref4.platform,\n    mod = _ref4.mod,\n    _action = _ref4.action;\n  return withBaseMod(config, {\n    platform: platform,\n    mod: mod,\n    isProvider: false,\n    action: function () {\n      var _action2 = _asyncToGenerator(function* (_ref5) {\n        var _ref5$modRequest = _ref5.modRequest,\n          nextMod = _ref5$modRequest.nextMod,\n          modRequest = _objectWithoutProperties(_ref5$modRequest, _excluded2),\n          modResults = _ref5.modResults,\n          config = _objectWithoutProperties(_ref5, _excluded3);\n        var results = yield _action(Object.assign({\n          modRequest: modRequest,\n          modResults: modResults\n        }, config));\n        return nextMod(results);\n      });\n      function action(_x2) {\n        return _action2.apply(this, arguments);\n      }\n      return action;\n    }()\n  });\n}","map":{"version":3,"sources":["../../src/plugins/withMod.ts"],"names":["EXPO_DEBUG","withBaseMod","config","platform","mod","action","skipEmptyMod","isProvider","isIntrospective","saveToInternal","mods","interceptedMod","noopMod","debugTrace","isDebug","_internal","stack","Error","getDebugPluginStackFromStackTrace","modStack","chalk","bold","PluginError","interceptingMod","modRequest","console","log","results","nextMod","saveToInternalObject","modResults","platformName","modName","stacktrace","treeStackLines","line","split","first","second","trim","push","plugins","map","match","filter","Boolean","plugin","includes","commonPlugins","reverse","pluginName","index","toLowerCase","red","blue","dim","join","withMod"],"mappings":"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","sourcesContent":["import { ExpoConfig } from '@expo/config-types';\nimport { JSONObject } from '@expo/json-file';\nimport chalk from 'chalk';\nimport { boolish } from 'getenv';\n\nimport { ExportedConfig, ExportedConfigWithProps, Mod, ModPlatform } from '../Plugin.types';\nimport { PluginError } from '../utils/errors';\n\nconst EXPO_DEBUG = boolish('EXPO_DEBUG', false);\n\nexport type BaseModOptions = {\n  platform: ModPlatform;\n  mod: string;\n  isProvider?: boolean;\n  skipEmptyMod?: boolean;\n  saveToInternal?: boolean;\n  /**\n   * If the mod supports introspection, and avoids making any filesystem modifications during compilation.\n   * By enabling, this mod, and all of its descendants will be run in introspection mode.\n   * This should only be used for static files like JSON or XML, and not for application files that require regexes,\n   * or complex static files that require other files to be generated like Xcode `.pbxproj`.\n   */\n  isIntrospective?: boolean;\n};\n\n/**\n * Plugin to intercept execution of a given `mod` with the given `action`.\n * If an action was already set on the given `config` config for `mod`, then it\n * will be provided to the `action` as `nextMod` when it's evaluated, otherwise\n * `nextMod` will be an identity function.\n *\n * @param config exported config\n * @param platform platform to target (ios or android)\n * @param mod name of the platform function to intercept\n * @param skipEmptyMod should skip running the action if there is no existing mod to intercept\n * @param saveToInternal should save the results to `_internal.modResults`, only enable this when the results are pure JSON.\n * @param isProvider should provide data up to the other mods.\n * @param action method to run on the mod when the config is compiled\n */\nexport function withBaseMod<T>(\n  config: ExportedConfig,\n  {\n    platform,\n    mod,\n    action,\n    skipEmptyMod,\n    isProvider,\n    isIntrospective,\n    saveToInternal,\n  }: BaseModOptions & { action: Mod<T> }\n): ExportedConfig {\n  if (!config.mods) {\n    config.mods = {};\n  }\n  if (!config.mods[platform]) {\n    config.mods[platform] = {};\n  }\n\n  let interceptedMod: Mod<T> = (config.mods[platform] as Record<string, any>)[mod];\n\n  // No existing mod to intercept\n  if (!interceptedMod) {\n    if (skipEmptyMod) {\n      // Skip running the action\n      return config;\n    }\n    // Use a noop mod and continue\n    const noopMod: Mod<T> = (config) => config;\n    interceptedMod = noopMod;\n  }\n\n  // Create a stack trace for debugging ahead of time\n  let debugTrace: string = '';\n  // Use the possibly user defined value. Otherwise fallback to the env variable.\n  // We support the env variable because user mods won't have _internal defined in time.\n  const isDebug = config._internal?.isDebug ?? EXPO_DEBUG;\n  if (isDebug) {\n    // Get a stack trace via the Error API\n    const stack = new Error().stack;\n    // Format the stack trace to create the debug log\n    debugTrace = getDebugPluginStackFromStackTrace(stack);\n    const modStack = chalk.bold(`${platform}.${mod}`);\n\n    debugTrace = `${modStack}: ${debugTrace}`;\n  }\n\n  // Prevent adding multiple providers to a mod.\n  // Base mods that provide files ignore any incoming modResults and therefore shouldn't have provider mods as parents.\n  if (interceptedMod.isProvider) {\n    if (isProvider) {\n      throw new PluginError(\n        `Cannot set provider mod for \"${platform}.${mod}\" because another is already being used.`,\n        'CONFLICTING_PROVIDER'\n      );\n    } else {\n      throw new PluginError(\n        `Cannot add mod to \"${platform}.${mod}\" because the provider has already been added. Provider must be the last mod added.`,\n        'INVALID_MOD_ORDER'\n      );\n    }\n  }\n\n  async function interceptingMod({ modRequest, ...config }: ExportedConfigWithProps<T>) {\n    if (isDebug) {\n      // In debug mod, log the plugin stack in the order which they were invoked\n      console.log(debugTrace);\n    }\n    const results = await action({\n      ...config,\n      modRequest: { ...modRequest, nextMod: interceptedMod },\n    });\n\n    if (saveToInternal) {\n      saveToInternalObject(results, platform, mod, results.modResults as unknown as JSONObject);\n    }\n    return results;\n  }\n\n  // Ensure this base mod is registered as the provider.\n  interceptingMod.isProvider = isProvider;\n\n  if (isIntrospective) {\n    // Register the mode as idempotent so introspection doesn't remove it.\n    interceptingMod.isIntrospective = isIntrospective;\n  }\n\n  (config.mods[platform] as any)[mod] = interceptingMod;\n\n  return config;\n}\n\nfunction saveToInternalObject(\n  config: Pick<ExpoConfig, '_internal'>,\n  platformName: ModPlatform,\n  modName: string,\n  results: JSONObject\n) {\n  if (!config._internal) config._internal = {};\n  if (!config._internal.modResults) config._internal.modResults = {};\n  if (!config._internal.modResults[platformName]) config._internal.modResults[platformName] = {};\n  config._internal.modResults[platformName][modName] = results;\n}\n\nfunction getDebugPluginStackFromStackTrace(stacktrace?: string): string {\n  if (!stacktrace) {\n    return '';\n  }\n\n  const treeStackLines: string[] = [];\n  for (const line of stacktrace.split('\\n')) {\n    const [first, second] = line.trim().split(' ');\n    if (first === 'at') {\n      treeStackLines.push(second);\n    }\n  }\n\n  const plugins = treeStackLines\n    .map((first) => {\n      // Match the first part of the stack trace against the plugin naming convention\n      // \"with\" followed by a capital letter.\n      return (\n        first?.match(/^(\\bwith[A-Z].*?\\b)/)?.[1]?.trim() ??\n        first?.match(/\\.(\\bwith[A-Z].*?\\b)/)?.[1]?.trim() ??\n        null\n      );\n    })\n    .filter(Boolean)\n    .filter((plugin) => {\n      // redundant as all debug logs are captured in withBaseMod\n      return !['withMod', 'withBaseMod', 'withExtendedMod'].includes(plugin!);\n    });\n\n  const commonPlugins = ['withPlugins', 'withRunOnce', 'withStaticPlugin'];\n\n  return (\n    (plugins as string[])\n      .reverse()\n      .map((pluginName, index) => {\n        // Base mods indicate a logical section.\n        if (pluginName.includes('BaseMod')) {\n          pluginName = chalk.bold(pluginName);\n        }\n        // highlight dangerous mods\n        if (pluginName.toLowerCase().includes('dangerous')) {\n          pluginName = chalk.red(pluginName);\n        }\n\n        if (index === 0) {\n          return chalk.blue(pluginName);\n        } else if (commonPlugins.includes(pluginName)) {\n          // Common mod names often clutter up the logs, dim them out\n          return chalk.dim(pluginName);\n        }\n        return pluginName;\n      })\n      // Join the results:\n      // withAndroidExpoPlugins ➜ withPlugins ➜ withIcons ➜ withDangerousMod ➜ withMod\n      .join(' ➜ ')\n  );\n}\n\n/**\n * Plugin to extend a mod function in the plugins config.\n *\n * @param config exported config\n * @param platform platform to target (ios or android)\n * @param mod name of the platform function to extend\n * @param action method to run on the mod when the config is compiled\n */\nexport function withMod<T>(\n  config: ExportedConfig,\n  {\n    platform,\n    mod,\n    action,\n  }: {\n    platform: ModPlatform;\n    mod: string;\n    action: Mod<T>;\n  }\n): ExportedConfig {\n  return withBaseMod(config, {\n    platform,\n    mod,\n    isProvider: false,\n    async action({ modRequest: { nextMod, ...modRequest }, modResults, ...config }) {\n      const results = await action({ modRequest, modResults: modResults as T, ...config });\n      return nextMod!(results as any);\n    },\n  });\n}\n"]},"metadata":{},"sourceType":"script"}