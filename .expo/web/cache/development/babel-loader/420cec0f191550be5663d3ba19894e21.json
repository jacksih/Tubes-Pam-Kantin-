{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.escapeAndroidString = escapeAndroidString;\nexports.format = format;\nexports.parseXMLAsync = parseXMLAsync;\nexports.readXMLAsync = readXMLAsync;\nexports.unescapeAndroidString = unescapeAndroidString;\nexports.writeXMLAsync = writeXMLAsync;\nfunction _fs() {\n  var data = _interopRequireDefault(require(\"fs\"));\n  _fs = function _fs() {\n    return data;\n  };\n  return data;\n}\nfunction _os() {\n  var data = require(\"os\");\n  _os = function _os() {\n    return data;\n  };\n  return data;\n}\nfunction _path() {\n  var data = _interopRequireDefault(require(\"path\"));\n  _path = function _path() {\n    return data;\n  };\n  return data;\n}\nfunction _xml2js() {\n  var data = require(\"xml2js\");\n  _xml2js = function _xml2js() {\n    return data;\n  };\n  return data;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction writeXMLAsync(_x) {\n  return _writeXMLAsync.apply(this, arguments);\n}\nfunction _writeXMLAsync() {\n  _writeXMLAsync = _asyncToGenerator(function* (options) {\n    var xml = format(options.xml);\n    yield _fs().default.promises.mkdir(_path().default.dirname(options.path), {\n      recursive: true\n    });\n    yield _fs().default.promises.writeFile(options.path, xml);\n  });\n  return _writeXMLAsync.apply(this, arguments);\n}\nfunction readXMLAsync(_x2) {\n  return _readXMLAsync.apply(this, arguments);\n}\nfunction _readXMLAsync() {\n  _readXMLAsync = _asyncToGenerator(function* (options) {\n    var _manifest$resources;\n    var contents = '';\n    try {\n      contents = yield _fs().default.promises.readFile(options.path, {\n        encoding: 'utf8',\n        flag: 'r'\n      });\n    } catch (_unused) {}\n    var parser = new (_xml2js().Parser)();\n    var manifest = yield parser.parseStringPromise(contents || options.fallback || '');\n    if (Array.isArray(manifest === null || manifest === void 0 ? void 0 : (_manifest$resources = manifest.resources) === null || _manifest$resources === void 0 ? void 0 : _manifest$resources.string)) {\n      for (var string of manifest === null || manifest === void 0 ? void 0 : (_manifest$resources2 = manifest.resources) === null || _manifest$resources2 === void 0 ? void 0 : _manifest$resources2.string) {\n        var _manifest$resources2;\n        if (string.$.translatable === 'false' || string.$.translatable === false) {\n          continue;\n        }\n        string._ = unescapeAndroidString(string._);\n      }\n    }\n    return manifest;\n  });\n  return _readXMLAsync.apply(this, arguments);\n}\nfunction parseXMLAsync(_x3) {\n  return _parseXMLAsync.apply(this, arguments);\n}\nfunction _parseXMLAsync() {\n  _parseXMLAsync = _asyncToGenerator(function* (contents) {\n    var xml = yield new (_xml2js().Parser)().parseStringPromise(contents);\n    return xml;\n  });\n  return _parseXMLAsync.apply(this, arguments);\n}\nvar stringTimesN = function stringTimesN(n, char) {\n  return Array(n + 1).join(char);\n};\nfunction format(manifest) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$indentLevel = _ref.indentLevel,\n    indentLevel = _ref$indentLevel === void 0 ? 2 : _ref$indentLevel,\n    _ref$newline = _ref.newline,\n    newline = _ref$newline === void 0 ? _os().EOL : _ref$newline;\n  var xmlInput;\n  if (typeof manifest === 'string') {\n    xmlInput = manifest;\n  } else if (manifest.toString) {\n    var _manifest$resources3;\n    var builder = new (_xml2js().Builder)({\n      headless: true\n    });\n    if (Array.isArray(manifest === null || manifest === void 0 ? void 0 : (_manifest$resources3 = manifest.resources) === null || _manifest$resources3 === void 0 ? void 0 : _manifest$resources3.string)) {\n      for (var string of manifest === null || manifest === void 0 ? void 0 : (_manifest$resources4 = manifest.resources) === null || _manifest$resources4 === void 0 ? void 0 : _manifest$resources4.string) {\n        var _manifest$resources4;\n        if (string.$.translatable === 'false' || string.$.translatable === false) {\n          continue;\n        }\n        string._ = escapeAndroidString(string._);\n      }\n    }\n    xmlInput = builder.buildObject(manifest);\n    return xmlInput;\n  } else {\n    throw new Error(\"Invalid XML value passed in: \" + manifest);\n  }\n  var indentString = stringTimesN(indentLevel, ' ');\n  var formatted = '';\n  var regex = /(>)(<)(\\/*)/g;\n  var xml = xmlInput.replace(regex, \"$1\" + newline + \"$2$3\");\n  var pad = 0;\n  xml.split(/\\r?\\n/).map(function (line) {\n    return line.trim();\n  }).forEach(function (line) {\n    var indent = 0;\n    if (line.match(/.+<\\/\\w[^>]*>$/)) {\n      indent = 0;\n    } else if (line.match(/^<\\/\\w/)) {\n      if (pad !== 0) {\n        pad -= 1;\n      }\n    } else if (line.match(/^<\\w([^>]*[^/])?>.*$/)) {\n      indent = 1;\n    } else {\n      indent = 0;\n    }\n    var padding = stringTimesN(pad, indentString);\n    formatted += padding + line + newline;\n    pad += indent;\n  });\n  return formatted.trim();\n}\nfunction escapeAndroidString(value) {\n  value = value.replace(/[\\n\\r\\t'\"@]/g, function (m) {\n    switch (m) {\n      case '\"':\n      case \"'\":\n      case '@':\n        return '\\\\' + m;\n      case '\\n':\n        return '\\\\n';\n      case '\\r':\n        return '\\\\r';\n      case '\\t':\n        return '\\\\t';\n      default:\n        throw new Error(\"Cannot escape unhandled XML character: \" + m);\n    }\n  });\n  if (value.match(/(^\\s|\\s$)/)) {\n    value = '\"' + value + '\"';\n  }\n  return value;\n}\nfunction unescapeAndroidString(value) {\n  return value.replace(/\\\\(.)/g, '$1');\n}","map":{"version":3,"sources":["../../src/utils/XML.ts"],"names":["writeXMLAsync","options","xml","format","promises","mkdir","path","dirname","recursive","fs","writeFile","readXMLAsync","contents","readFile","encoding","flag","parser","Parser","manifest","parseStringPromise","fallback","Array","isArray","resources","string","$","translatable","_","unescapeAndroidString","parseXMLAsync","stringTimesN","n","char","join","indentLevel","newline","EOL","xmlInput","toString","builder","Builder","headless","escapeAndroidString","buildObject","Error","indentString","formatted","regex","replace","pad","split","map","line","trim","forEach","indent","match","padding","value","m"],"mappings":"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","sourcesContent":["import fs from 'fs';\nimport { EOL } from 'os';\nimport path from 'path';\nimport { Builder, Parser } from 'xml2js';\n\nexport type XMLValue = boolean | number | string | null | XMLArray | XMLObject;\n\nexport interface XMLArray extends Array<XMLValue> {}\n\nexport interface XMLObject {\n  [key: string]: XMLValue | undefined;\n}\n\nexport async function writeXMLAsync(options: { path: string; xml: any }): Promise<void> {\n  const xml = format(options.xml);\n  await fs.promises.mkdir(path.dirname(options.path), { recursive: true });\n  await fs.promises.writeFile(options.path, xml);\n}\n\nexport async function readXMLAsync(options: {\n  path: string;\n  fallback?: string | null;\n}): Promise<XMLObject> {\n  let contents: string = '';\n  try {\n    contents = await fs.promises.readFile(options.path, { encoding: 'utf8', flag: 'r' });\n  } catch {\n    // catch and use fallback\n  }\n  const parser = new Parser();\n  const manifest = await parser.parseStringPromise(contents || options.fallback || '');\n\n  // For strings.xml\n  if (Array.isArray(manifest?.resources?.string)) {\n    for (const string of manifest?.resources?.string) {\n      if (string.$.translatable === 'false' || string.$.translatable === false) {\n        continue;\n      }\n      string._ = unescapeAndroidString(string._);\n    }\n  }\n\n  return manifest;\n}\n\nexport async function parseXMLAsync(contents: string): Promise<XMLObject> {\n  const xml = await new Parser().parseStringPromise(contents);\n  return xml;\n}\n\nconst stringTimesN = (n: number, char: string) => Array(n + 1).join(char);\n\nexport function format(manifest: any, { indentLevel = 2, newline = EOL } = {}): string {\n  let xmlInput: string;\n  if (typeof manifest === 'string') {\n    xmlInput = manifest;\n  } else if (manifest.toString) {\n    const builder = new Builder({\n      headless: true,\n    });\n\n    // For strings.xml\n    if (Array.isArray(manifest?.resources?.string)) {\n      for (const string of manifest?.resources?.string) {\n        if (string.$.translatable === 'false' || string.$.translatable === false) {\n          continue;\n        }\n        string._ = escapeAndroidString(string._);\n      }\n    }\n\n    xmlInput = builder.buildObject(manifest);\n\n    return xmlInput;\n  } else {\n    throw new Error(`Invalid XML value passed in: ${manifest}`);\n  }\n  const indentString = stringTimesN(indentLevel, ' ');\n\n  let formatted = '';\n  const regex = /(>)(<)(\\/*)/g;\n  const xml = xmlInput.replace(regex, `$1${newline}$2$3`);\n  let pad = 0;\n  xml\n    .split(/\\r?\\n/)\n    .map((line: string) => line.trim())\n    .forEach((line: string) => {\n      let indent = 0;\n      if (line.match(/.+<\\/\\w[^>]*>$/)) {\n        indent = 0;\n      } else if (line.match(/^<\\/\\w/)) {\n        if (pad !== 0) {\n          pad -= 1;\n        }\n      } else if (line.match(/^<\\w([^>]*[^/])?>.*$/)) {\n        indent = 1;\n      } else {\n        indent = 0;\n      }\n\n      const padding = stringTimesN(pad, indentString);\n      formatted += padding + line + newline;\n      pad += indent;\n    });\n\n  return formatted.trim();\n}\n\n/**\n * Escapes Android string literals, specifically characters `\"`, `'`, `\\`, `\\n`, `\\r`, `\\t`\n *\n * @param value unescaped Android XML string literal.\n */\nexport function escapeAndroidString(value: string): string {\n  value = value.replace(/[\\n\\r\\t'\"@]/g, (m) => {\n    switch (m) {\n      case '\"':\n      case \"'\":\n      case '@':\n        return '\\\\' + m;\n      case '\\n':\n        return '\\\\n';\n      case '\\r':\n        return '\\\\r';\n      case '\\t':\n        return '\\\\t';\n      default:\n        throw new Error(`Cannot escape unhandled XML character: ${m}`);\n    }\n  });\n  if (value.match(/(^\\s|\\s$)/)) {\n    value = '\"' + value + '\"';\n  }\n  return value;\n}\n\nexport function unescapeAndroidString(value: string): string {\n  return value.replace(/\\\\(.)/g, '$1');\n}\n"]},"metadata":{},"sourceType":"script"}