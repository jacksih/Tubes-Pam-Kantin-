{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getApplicationIdAsync = getApplicationIdAsync;\nexports.getPackage = getPackage;\nexports.renameJniOnDiskForType = renameJniOnDiskForType;\nexports.renamePackageOnDisk = renamePackageOnDisk;\nexports.renamePackageOnDiskForType = renamePackageOnDiskForType;\nexports.setPackageInAndroidManifest = setPackageInAndroidManifest;\nexports.setPackageInBuildGradle = setPackageInBuildGradle;\nexports.withPackageRefactor = exports.withPackageManifest = exports.withPackageGradle = void 0;\nfunction _debug() {\n  var data = _interopRequireDefault(require(\"debug\"));\n  _debug = function _debug() {\n    return data;\n  };\n  return data;\n}\nfunction _fs() {\n  var data = _interopRequireDefault(require(\"fs\"));\n  _fs = function _fs() {\n    return data;\n  };\n  return data;\n}\nfunction _glob() {\n  var data = require(\"glob\");\n  _glob = function _glob() {\n    return data;\n  };\n  return data;\n}\nfunction _path() {\n  var data = _interopRequireDefault(require(\"path\"));\n  _path = function _path() {\n    return data;\n  };\n  return data;\n}\nfunction _androidPlugins() {\n  var data = require(\"../plugins/android-plugins\");\n  _androidPlugins = function _androidPlugins() {\n    return data;\n  };\n  return data;\n}\nfunction _withDangerousMod() {\n  var data = require(\"../plugins/withDangerousMod\");\n  _withDangerousMod = function _withDangerousMod() {\n    return data;\n  };\n  return data;\n}\nfunction _modules() {\n  var data = require(\"../utils/modules\");\n  _modules = function _modules() {\n    return data;\n  };\n  return data;\n}\nfunction _warnings() {\n  var data = require(\"../utils/warnings\");\n  _warnings = function _warnings() {\n    return data;\n  };\n  return data;\n}\nfunction _Paths() {\n  var data = require(\"./Paths\");\n  _Paths = function _Paths() {\n    return data;\n  };\n  return data;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar debug = (0, _debug().default)('expo:config-plugins:android:package');\nvar withPackageManifest = (0, _androidPlugins().createAndroidManifestPlugin)(setPackageInAndroidManifest, 'withPackageManifest');\nexports.withPackageManifest = withPackageManifest;\nvar withPackageGradle = function withPackageGradle(config) {\n  return (0, _androidPlugins().withAppBuildGradle)(config, function (config) {\n    if (config.modResults.language === 'groovy') {\n      config.modResults.contents = setPackageInBuildGradle(config, config.modResults.contents);\n    } else {\n      (0, _warnings().addWarningAndroid)('android.package', \"Cannot automatically configure app build.gradle if it's not groovy\");\n    }\n    return config;\n  });\n};\nexports.withPackageGradle = withPackageGradle;\nvar withPackageRefactor = function withPackageRefactor(config) {\n  return (0, _withDangerousMod().withDangerousMod)(config, ['android', function () {\n    var _ref = _asyncToGenerator(function* (config) {\n      yield renamePackageOnDisk(config, config.modRequest.projectRoot);\n      return config;\n    });\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }()]);\n};\nexports.withPackageRefactor = withPackageRefactor;\nfunction getPackage(config) {\n  var _config$android$packa, _config$android;\n  return (_config$android$packa = (_config$android = config.android) === null || _config$android === void 0 ? void 0 : _config$android.package) !== null && _config$android$packa !== void 0 ? _config$android$packa : null;\n}\nfunction getPackageRoot(projectRoot, type) {\n  return _path().default.join(projectRoot, 'android', 'app', 'src', type, 'java');\n}\nfunction getCurrentPackageName(projectRoot, packageRoot) {\n  var mainApplication = (0, _Paths().getProjectFilePath)(projectRoot, 'MainApplication');\n  var packagePath = _path().default.dirname(mainApplication);\n  var packagePathParts = _path().default.relative(packageRoot, packagePath).split(_path().default.sep).filter(Boolean);\n  return packagePathParts.join('.');\n}\nfunction getCurrentPackageForProjectFile(projectRoot, packageRoot, fileName, type) {\n  var filePath = (0, _glob().sync)(_path().default.join(projectRoot, \"android/app/src/\" + type + \"/java/**/\" + fileName + \".@(java|kt)\"))[0];\n  if (!filePath) {\n    return null;\n  }\n  var packagePath = _path().default.dirname(filePath);\n  var packagePathParts = _path().default.relative(packageRoot, packagePath).split(_path().default.sep).filter(Boolean);\n  return packagePathParts.join('.');\n}\nfunction getCurrentPackageNameForType(projectRoot, type) {\n  var packageRoot = getPackageRoot(projectRoot, type);\n  if (type === 'main') {\n    return getCurrentPackageName(projectRoot, packageRoot);\n  }\n  return getCurrentPackageForProjectFile(projectRoot, packageRoot, '*', type);\n}\nfunction renamePackageOnDisk(_x2, _x3) {\n  return _renamePackageOnDisk.apply(this, arguments);\n}\nfunction _renamePackageOnDisk() {\n  _renamePackageOnDisk = _asyncToGenerator(function* (config, projectRoot) {\n    var newPackageName = getPackage(config);\n    if (newPackageName === null) {\n      return;\n    }\n    for (var type of ['main', 'debug']) {\n      yield renameJniOnDiskForType({\n        projectRoot: projectRoot,\n        type: type,\n        packageName: newPackageName\n      });\n      yield renamePackageOnDiskForType({\n        projectRoot: projectRoot,\n        type: type,\n        packageName: newPackageName\n      });\n    }\n  });\n  return _renamePackageOnDisk.apply(this, arguments);\n}\nfunction renameJniOnDiskForType(_x4) {\n  return _renameJniOnDiskForType.apply(this, arguments);\n}\nfunction _renameJniOnDiskForType() {\n  _renameJniOnDiskForType = _asyncToGenerator(function* (_ref2) {\n    var projectRoot = _ref2.projectRoot,\n      type = _ref2.type,\n      packageName = _ref2.packageName;\n    if (!packageName) {\n      return;\n    }\n    var currentPackageName = getCurrentPackageNameForType(projectRoot, type);\n    if (!currentPackageName || !packageName || currentPackageName === packageName) {\n      return;\n    }\n    var jniRoot = _path().default.join(projectRoot, 'android', 'app', 'src', type, 'jni');\n    var filesToUpdate = _toConsumableArray((0, _glob().sync)('**/*', {\n      cwd: jniRoot,\n      absolute: true\n    }));\n    filesToUpdate.forEach(function (filepath) {\n      try {\n        if (_fs().default.lstatSync(filepath).isFile() && ['.h', '.cpp'].includes(_path().default.extname(filepath))) {\n          var contents = _fs().default.readFileSync(filepath).toString();\n          contents = contents.replace(new RegExp(transformJavaClassDescriptor(currentPackageName).replace(/\\//g, '\\\\/'), 'g'), transformJavaClassDescriptor(packageName));\n          _fs().default.writeFileSync(filepath, contents);\n        }\n      } catch (_unused) {\n        debug(\"Error updating \\\"\" + filepath + \"\\\" for type \\\"\" + type + \"\\\"\");\n      }\n    });\n  });\n  return _renameJniOnDiskForType.apply(this, arguments);\n}\nfunction renamePackageOnDiskForType(_x5) {\n  return _renamePackageOnDiskForType.apply(this, arguments);\n}\nfunction _renamePackageOnDiskForType() {\n  _renamePackageOnDiskForType = _asyncToGenerator(function* (_ref3) {\n    var _path$default, _path$default2;\n    var projectRoot = _ref3.projectRoot,\n      type = _ref3.type,\n      packageName = _ref3.packageName;\n    if (!packageName) {\n      return;\n    }\n    var currentPackageName = getCurrentPackageNameForType(projectRoot, type);\n    debug(\"Found package \\\"\" + currentPackageName + \"\\\" for type \\\"\" + type + \"\\\"\");\n    if (!currentPackageName || currentPackageName === packageName) {\n      return;\n    }\n    debug(\"Refactor \\\"\" + currentPackageName + \"\\\" to \\\"\" + packageName + \"\\\" for type \\\"\" + type + \"\\\"\");\n    var packageRoot = getPackageRoot(projectRoot, type);\n    if (!(yield (0, _modules().directoryExistsAsync)(packageRoot))) {\n      debug(\"- skipping refactor of missing directory: \" + packageRoot);\n      return;\n    }\n    var currentPackagePath = (_path$default = _path().default).join.apply(_path$default, [packageRoot].concat(_toConsumableArray(currentPackageName.split('.'))));\n    var newPackagePath = (_path$default2 = _path().default).join.apply(_path$default2, [packageRoot].concat(_toConsumableArray(packageName.split('.'))));\n    _fs().default.mkdirSync(newPackagePath, {\n      recursive: true\n    });\n    (0, _glob().sync)('**/*', {\n      cwd: currentPackagePath\n    }).forEach(function (relativePath) {\n      var filepath = _path().default.join(currentPackagePath, relativePath);\n      if (_fs().default.lstatSync(filepath).isFile()) {\n        moveFileSync(filepath, _path().default.join(newPackagePath, relativePath));\n      } else {\n        _fs().default.mkdirSync(filepath, {\n          recursive: true\n        });\n      }\n    });\n    var oldPathParts = currentPackageName.split('.');\n    while (oldPathParts.length) {\n      var _path$default3;\n      var pathToCheck = (_path$default3 = _path().default).join.apply(_path$default3, [packageRoot].concat(_toConsumableArray(oldPathParts)));\n      try {\n        var files = _fs().default.readdirSync(pathToCheck);\n        if (files.length === 0) {\n          _fs().default.rmdirSync(pathToCheck);\n        }\n      } finally {\n        oldPathParts.pop();\n      }\n    }\n    var filesToUpdate = _toConsumableArray((0, _glob().sync)('**/*', {\n      cwd: newPackagePath,\n      absolute: true\n    }));\n    if (type === 'main') {\n      filesToUpdate.push(_path().default.join(projectRoot, 'android', 'app', 'BUCK'));\n    }\n    filesToUpdate.forEach(function (filepath) {\n      try {\n        if (_fs().default.lstatSync(filepath).isFile()) {\n          var contents = _fs().default.readFileSync(filepath).toString();\n          contents = contents.replace(new RegExp(currentPackageName, 'g'), packageName);\n          if (['.h', '.cpp'].includes(_path().default.extname(filepath))) {\n            contents = contents.replace(new RegExp(transformJavaClassDescriptor(currentPackageName).replace(/\\//g, '\\\\'), 'g'), transformJavaClassDescriptor(packageName));\n          }\n          _fs().default.writeFileSync(filepath, contents);\n        }\n      } catch (_unused2) {\n        debug(\"Error updating \\\"\" + filepath + \"\\\" for type \\\"\" + type + \"\\\"\");\n      }\n    });\n  });\n  return _renamePackageOnDiskForType.apply(this, arguments);\n}\nfunction moveFileSync(src, dest) {\n  _fs().default.mkdirSync(_path().default.dirname(dest), {\n    recursive: true\n  });\n  _fs().default.renameSync(src, dest);\n}\nfunction setPackageInBuildGradle(config, buildGradle) {\n  var packageName = getPackage(config);\n  if (packageName === null) {\n    return buildGradle;\n  }\n  var pattern = new RegExp(\"applicationId ['\\\"].*['\\\"]\");\n  return buildGradle.replace(pattern, \"applicationId '\" + packageName + \"'\");\n}\nfunction setPackageInAndroidManifest(config, androidManifest) {\n  var packageName = getPackage(config);\n  if (packageName) {\n    androidManifest.manifest.$.package = packageName;\n  } else {\n    delete androidManifest.manifest.$.package;\n  }\n  return androidManifest;\n}\nfunction getApplicationIdAsync(_x6) {\n  return _getApplicationIdAsync.apply(this, arguments);\n}\nfunction _getApplicationIdAsync() {\n  _getApplicationIdAsync = _asyncToGenerator(function* (projectRoot) {\n    var _matchResult$;\n    var buildGradlePath = (0, _Paths().getAppBuildGradleFilePath)(projectRoot);\n    if (!_fs().default.existsSync(buildGradlePath)) {\n      return null;\n    }\n    var buildGradle = yield _fs().default.promises.readFile(buildGradlePath, 'utf8');\n    var matchResult = buildGradle.match(/applicationId ['\"](.*)['\"]/);\n    return (_matchResult$ = matchResult === null || matchResult === void 0 ? void 0 : matchResult[1]) !== null && _matchResult$ !== void 0 ? _matchResult$ : null;\n  });\n  return _getApplicationIdAsync.apply(this, arguments);\n}\nfunction transformJavaClassDescriptor(packageName) {\n  return \"L\" + packageName.replace(/\\./g, '/');\n}","map":{"version":3,"sources":["../../src/android/Package.ts"],"names":["debug","withPackageManifest","setPackageInAndroidManifest","withPackageGradle","config","modResults","language","contents","setPackageInBuildGradle","withPackageRefactor","renamePackageOnDisk","modRequest","projectRoot","getPackage","android","package","getPackageRoot","type","path","join","getCurrentPackageName","packageRoot","mainApplication","packagePath","dirname","packagePathParts","relative","split","sep","filter","Boolean","getCurrentPackageForProjectFile","fileName","filePath","getCurrentPackageNameForType","newPackageName","renameJniOnDiskForType","packageName","renamePackageOnDiskForType","currentPackageName","jniRoot","filesToUpdate","cwd","absolute","forEach","filepath","fs","lstatSync","isFile","includes","extname","readFileSync","toString","replace","RegExp","transformJavaClassDescriptor","writeFileSync","currentPackagePath","newPackagePath","mkdirSync","recursive","relativePath","moveFileSync","oldPathParts","length","pathToCheck","files","readdirSync","rmdirSync","pop","push","src","dest","renameSync","buildGradle","pattern","androidManifest","manifest","$","getApplicationIdAsync","buildGradlePath","existsSync","promises","readFile","matchResult","match"],"mappings":"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","sourcesContent":["import { ExpoConfig } from '@expo/config-types';\nimport Debug from 'debug';\nimport fs from 'fs';\nimport { sync as globSync } from 'glob';\nimport path from 'path';\n\nimport { ConfigPlugin } from '../Plugin.types';\nimport { createAndroidManifestPlugin, withAppBuildGradle } from '../plugins/android-plugins';\nimport { withDangerousMod } from '../plugins/withDangerousMod';\nimport { directoryExistsAsync } from '../utils/modules';\nimport { addWarningAndroid } from '../utils/warnings';\nimport { AndroidManifest } from './Manifest';\nimport { getAppBuildGradleFilePath, getProjectFilePath } from './Paths';\n\nconst debug = Debug('expo:config-plugins:android:package');\n\nexport const withPackageManifest = createAndroidManifestPlugin(\n  setPackageInAndroidManifest,\n  'withPackageManifest'\n);\n\nexport const withPackageGradle: ConfigPlugin = (config) => {\n  return withAppBuildGradle(config, (config) => {\n    if (config.modResults.language === 'groovy') {\n      config.modResults.contents = setPackageInBuildGradle(config, config.modResults.contents);\n    } else {\n      addWarningAndroid(\n        'android.package',\n        `Cannot automatically configure app build.gradle if it's not groovy`\n      );\n    }\n    return config;\n  });\n};\n\nexport const withPackageRefactor: ConfigPlugin = (config) => {\n  return withDangerousMod(config, [\n    'android',\n    async (config) => {\n      await renamePackageOnDisk(config, config.modRequest.projectRoot);\n      return config;\n    },\n  ]);\n};\n\nexport function getPackage(config: Pick<ExpoConfig, 'android'>) {\n  return config.android?.package ?? null;\n}\n\nfunction getPackageRoot(projectRoot: string, type: 'main' | 'debug') {\n  return path.join(projectRoot, 'android', 'app', 'src', type, 'java');\n}\n\nfunction getCurrentPackageName(projectRoot: string, packageRoot: string) {\n  const mainApplication = getProjectFilePath(projectRoot, 'MainApplication');\n  const packagePath = path.dirname(mainApplication);\n  const packagePathParts = path.relative(packageRoot, packagePath).split(path.sep).filter(Boolean);\n\n  return packagePathParts.join('.');\n}\n\nfunction getCurrentPackageForProjectFile(\n  projectRoot: string,\n  packageRoot: string,\n  fileName: string,\n  type: string\n) {\n  const filePath = globSync(\n    path.join(projectRoot, `android/app/src/${type}/java/**/${fileName}.@(java|kt)`)\n  )[0];\n\n  if (!filePath) {\n    return null;\n  }\n\n  const packagePath = path.dirname(filePath);\n  const packagePathParts = path.relative(packageRoot, packagePath).split(path.sep).filter(Boolean);\n\n  return packagePathParts.join('.');\n}\n\nfunction getCurrentPackageNameForType(projectRoot: string, type: string): string | null {\n  const packageRoot = getPackageRoot(projectRoot, type as any);\n\n  if (type === 'main') {\n    return getCurrentPackageName(projectRoot, packageRoot);\n  }\n  // debug, etc..\n  return getCurrentPackageForProjectFile(projectRoot, packageRoot, '*', type);\n}\n\n// NOTE(brentvatne): this assumes that our MainApplication.java file is in the root of the package\n// this makes sense for standard react-native projects but may not apply in customized projects, so if\n// we want this to be runnable in any app we need to handle other possibilities\nexport async function renamePackageOnDisk(\n  config: Pick<ExpoConfig, 'android'>,\n  projectRoot: string\n) {\n  const newPackageName = getPackage(config);\n  if (newPackageName === null) {\n    return;\n  }\n\n  for (const type of ['main', 'debug']) {\n    await renameJniOnDiskForType({ projectRoot, type, packageName: newPackageName });\n    await renamePackageOnDiskForType({ projectRoot, type, packageName: newPackageName });\n  }\n}\n\nexport async function renameJniOnDiskForType({\n  projectRoot,\n  type,\n  packageName,\n}: {\n  projectRoot: string;\n  type: string;\n  packageName: string;\n}) {\n  if (!packageName) {\n    return;\n  }\n\n  const currentPackageName = getCurrentPackageNameForType(projectRoot, type);\n  if (!currentPackageName || !packageName || currentPackageName === packageName) {\n    return;\n  }\n\n  const jniRoot = path.join(projectRoot, 'android', 'app', 'src', type, 'jni');\n  const filesToUpdate = [...globSync('**/*', { cwd: jniRoot, absolute: true })];\n  // Replace all occurrences of the path in the project\n  filesToUpdate.forEach((filepath: string) => {\n    try {\n      if (fs.lstatSync(filepath).isFile() && ['.h', '.cpp'].includes(path.extname(filepath))) {\n        let contents = fs.readFileSync(filepath).toString();\n        contents = contents.replace(\n          new RegExp(transformJavaClassDescriptor(currentPackageName).replace(/\\//g, '\\\\/'), 'g'),\n          transformJavaClassDescriptor(packageName)\n        );\n        fs.writeFileSync(filepath, contents);\n      }\n    } catch {\n      debug(`Error updating \"${filepath}\" for type \"${type}\"`);\n    }\n  });\n}\n\nexport async function renamePackageOnDiskForType({\n  projectRoot,\n  type,\n  packageName,\n}: {\n  projectRoot: string;\n  type: string;\n  packageName: string;\n}) {\n  if (!packageName) {\n    return;\n  }\n\n  const currentPackageName = getCurrentPackageNameForType(projectRoot, type);\n  debug(`Found package \"${currentPackageName}\" for type \"${type}\"`);\n  if (!currentPackageName || currentPackageName === packageName) {\n    return;\n  }\n  debug(`Refactor \"${currentPackageName}\" to \"${packageName}\" for type \"${type}\"`);\n  const packageRoot = getPackageRoot(projectRoot, type as any);\n  // Set up our paths\n  if (!(await directoryExistsAsync(packageRoot))) {\n    debug(`- skipping refactor of missing directory: ${packageRoot}`);\n    return;\n  }\n\n  const currentPackagePath = path.join(packageRoot, ...currentPackageName.split('.'));\n  const newPackagePath = path.join(packageRoot, ...packageName.split('.'));\n\n  // Create the new directory\n  fs.mkdirSync(newPackagePath, { recursive: true });\n\n  // Move everything from the old directory over\n  globSync('**/*', { cwd: currentPackagePath }).forEach((relativePath) => {\n    const filepath = path.join(currentPackagePath, relativePath);\n    if (fs.lstatSync(filepath).isFile()) {\n      moveFileSync(filepath, path.join(newPackagePath, relativePath));\n    } else {\n      fs.mkdirSync(filepath, { recursive: true });\n    }\n  });\n\n  // Remove the old directory recursively from com/old/package to com/old and com,\n  // as long as the directories are empty\n  const oldPathParts = currentPackageName.split('.');\n  while (oldPathParts.length) {\n    const pathToCheck = path.join(packageRoot, ...oldPathParts);\n    try {\n      const files = fs.readdirSync(pathToCheck);\n      if (files.length === 0) {\n        fs.rmdirSync(pathToCheck);\n      }\n    } finally {\n      oldPathParts.pop();\n    }\n  }\n\n  const filesToUpdate = [...globSync('**/*', { cwd: newPackagePath, absolute: true })];\n  // Only update the BUCK file to match the main package name\n  if (type === 'main') {\n    filesToUpdate.push(path.join(projectRoot, 'android', 'app', 'BUCK'));\n  }\n  // Replace all occurrences of the path in the project\n  filesToUpdate.forEach((filepath: string) => {\n    try {\n      if (fs.lstatSync(filepath).isFile()) {\n        let contents = fs.readFileSync(filepath).toString();\n        contents = contents.replace(new RegExp(currentPackageName!, 'g'), packageName);\n        if (['.h', '.cpp'].includes(path.extname(filepath))) {\n          contents = contents.replace(\n            new RegExp(transformJavaClassDescriptor(currentPackageName).replace(/\\//g, '\\\\'), 'g'),\n            transformJavaClassDescriptor(packageName)\n          );\n        }\n        fs.writeFileSync(filepath, contents);\n      }\n    } catch {\n      debug(`Error updating \"${filepath}\" for type \"${type}\"`);\n    }\n  });\n}\n\nfunction moveFileSync(src: string, dest: string) {\n  fs.mkdirSync(path.dirname(dest), { recursive: true });\n  fs.renameSync(src, dest);\n}\n\nexport function setPackageInBuildGradle(config: Pick<ExpoConfig, 'android'>, buildGradle: string) {\n  const packageName = getPackage(config);\n  if (packageName === null) {\n    return buildGradle;\n  }\n\n  const pattern = new RegExp(`applicationId ['\"].*['\"]`);\n  return buildGradle.replace(pattern, `applicationId '${packageName}'`);\n}\n\nexport function setPackageInAndroidManifest(\n  config: Pick<ExpoConfig, 'android'>,\n  androidManifest: AndroidManifest\n) {\n  const packageName = getPackage(config);\n\n  if (packageName) {\n    androidManifest.manifest.$.package = packageName;\n  } else {\n    delete androidManifest.manifest.$.package;\n  }\n\n  return androidManifest;\n}\n\nexport async function getApplicationIdAsync(projectRoot: string): Promise<string | null> {\n  const buildGradlePath = getAppBuildGradleFilePath(projectRoot);\n  if (!fs.existsSync(buildGradlePath)) {\n    return null;\n  }\n  const buildGradle = await fs.promises.readFile(buildGradlePath, 'utf8');\n  const matchResult = buildGradle.match(/applicationId ['\"](.*)['\"]/);\n  // TODO add fallback for legacy cases to read from AndroidManifest.xml\n  return matchResult?.[1] ?? null;\n}\n\n/**\n * Transform a java package name to java class descriptor,\n * e.g. `com.helloworld` -> `Lcom/helloworld`.\n */\nfunction transformJavaClassDescriptor(packageName: string) {\n  return `L${packageName.replace(/\\./g, '/')}`;\n}\n"]},"metadata":{},"sourceType":"script"}