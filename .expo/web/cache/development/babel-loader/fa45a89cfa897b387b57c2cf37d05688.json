{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.copyFilePathToPathAsync = copyFilePathToPathAsync;\nexports.removeFile = removeFile;\nfunction _fs() {\n  var data = _interopRequireDefault(require(\"fs\"));\n  _fs = function _fs() {\n    return data;\n  };\n  return data;\n}\nfunction _path() {\n  var data = _interopRequireDefault(require(\"path\"));\n  _path = function _path() {\n    return data;\n  };\n  return data;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction copyFilePathToPathAsync(_x, _x2) {\n  return _copyFilePathToPathAsync.apply(this, arguments);\n}\nfunction _copyFilePathToPathAsync() {\n  _copyFilePathToPathAsync = _asyncToGenerator(function* (src, dest) {\n    var srcFile = yield _fs().default.promises.readFile(src);\n    yield _fs().default.promises.mkdir(_path().default.dirname(dest), {\n      recursive: true\n    });\n    yield _fs().default.promises.writeFile(dest, srcFile);\n  });\n  return _copyFilePathToPathAsync.apply(this, arguments);\n}\nfunction removeFile(filePath) {\n  try {\n    _fs().default.unlinkSync(filePath);\n    return true;\n  } catch (error) {\n    if (error.code === 'ENOENT') {\n      return false;\n    }\n    throw error;\n  }\n}","map":{"version":3,"sources":["../../src/utils/fs.ts"],"names":["copyFilePathToPathAsync","src","dest","srcFile","fs","promises","readFile","mkdir","path","dirname","recursive","writeFile","removeFile","filePath","unlinkSync","error","code"],"mappings":";;;;;;;;AAAA,SAAA,GAAA,GAAA;EAAA,IAAA,IAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,IAAA,CAAA,CAAA;EAAA,GAAA,GAAA,eAAA;IAAA,OAAA,IAAA;EAAA,CAAA;EAAA,OAAA,IAAA;AAAA;AACA,SAAA,KAAA,GAAA;EAAA,IAAA,IAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,MAAA,CAAA,CAAA;EAAA,KAAA,GAAA,iBAAA;IAAA,OAAA,IAAA;EAAA,CAAA;EAAA,OAAA,IAAA;AAAA;;;;;;SAGsBA,uBAAf;EAAA;AAAA;AAAA;EAAA,6CAAA,WAAuCC,GAAvC,EAAoDC,IAApD,EAAiF;IACtF,IAAMC,OAAO,SAASC,GAAAA,EAAAA,CAAAA,OAAAA,CAAGC,QAAHD,CAAYE,QAAZF,CAAqBH,GAArBG,CAAtB;IACA,MAAM,GAAA,EAAA,CAAA,OAAA,CAAGC,QAAH,CAAYE,KAAZ,CAAkBC,KAAAA,EAAAA,CAAAA,OAAAA,CAAKC,OAALD,CAAaN,IAAbM,CAAlB,EAAsC;MAAEE,SAAS,EAAE;IAAb,CAAtC,CAAN;IACA,MAAMN,GAAAA,EAAAA,CAAAA,OAAAA,CAAGC,QAAHD,CAAYO,SAAZP,CAAsBF,IAAtBE,EAA4BD,OAA5BC,CAAN;EACD,CAAA;EAAA;AAAA;AAGM,SAASQ,UAAT,CAAoBC,QAApB,EAA+C;EACpD,IAAI;IACFT,GAAAA,EAAAA,CAAAA,OAAAA,CAAGU,UAAHV,CAAcS,QAAdT,CAAAA;IACA,OAAO,IAAP;EACD,CAHD,CAGE,OAAOW,KAAP,EAAmB;IAEnB,IAAIA,KAAK,CAACC,IAAND,KAAe,QAAnB,EAA6B;MAC3B,OAAO,KAAP;IACD;IACD,MAAMA,KAAN;EACD;AACF","sourcesContent":["import fs from 'fs';\nimport path from 'path';\n\n/** A basic function that copies a single file to another file location. */\nexport async function copyFilePathToPathAsync(src: string, dest: string): Promise<void> {\n  const srcFile = await fs.promises.readFile(src);\n  await fs.promises.mkdir(path.dirname(dest), { recursive: true });\n  await fs.promises.writeFile(dest, srcFile);\n}\n\n/** Remove a single file (not directory). Returns `true` if a file was actually deleted. */\nexport function removeFile(filePath: string): boolean {\n  try {\n    fs.unlinkSync(filePath);\n    return true;\n  } catch (error: any) {\n    // Skip if the remove did nothing.\n    if (error.code === 'ENOENT') {\n      return false;\n    }\n    throw error;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}