{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evalConfig = evalConfig;\nexports.resolveConfigExport = resolveConfigExport;\nfunction _fs() {\n  var data = require(\"fs\");\n  _fs = function _fs() {\n    return data;\n  };\n  return data;\n}\nfunction _requireFromString() {\n  var data = _interopRequireDefault(require(\"require-from-string\"));\n  _requireFromString = function _requireFromString() {\n    return data;\n  };\n  return data;\n}\nfunction _sucrase() {\n  var data = require(\"sucrase\");\n  _sucrase = function _sucrase() {\n    return data;\n  };\n  return data;\n}\nfunction _Errors() {\n  var data = require(\"./Errors\");\n  _Errors = function _Errors() {\n    return data;\n  };\n  return data;\n}\nfunction _Serialize() {\n  var data = require(\"./Serialize\");\n  _Serialize = function _Serialize() {\n    return data;\n  };\n  return data;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction evalConfig(configFile, request) {\n  var contents = (0, _fs().readFileSync)(configFile, 'utf8');\n  var result;\n  try {\n    var _ref = (0, _sucrase().transform)(contents, {\n        filePath: configFile,\n        transforms: ['typescript', 'imports']\n      }),\n      code = _ref.code;\n    result = (0, _requireFromString().default)(code, configFile);\n  } catch (error) {\n    var location = extractLocationFromSyntaxError(error);\n    if (location) {\n      var _require = require('@babel/code-frame'),\n        codeFrameColumns = _require.codeFrameColumns;\n      var codeFrame = codeFrameColumns(contents, {\n        start: error.loc\n      }, {\n        highlightCode: true\n      });\n      error.codeFrame = codeFrame;\n      error.message += \"\\n\" + codeFrame;\n    } else {\n      var importantStack = extractImportantStackFromNodeError(error);\n      if (importantStack) {\n        error.message += \"\\n\" + importantStack;\n      }\n    }\n    throw error;\n  }\n  return resolveConfigExport(result, configFile, request);\n}\nfunction extractLocationFromSyntaxError(error) {\n  if (error.loc) {\n    return error.loc;\n  }\n  if ('lineNumber' in error && 'columnNumber' in error) {\n    return {\n      line: error.lineNumber,\n      column: error.columnNumber\n    };\n  }\n  return null;\n}\nfunction extractImportantStackFromNodeError(error) {\n  if (isSyntaxError(error)) {\n    var _error$stack;\n    var traces = (_error$stack = error.stack) === null || _error$stack === void 0 ? void 0 : _error$stack.split('\\n').filter(function (line) {\n      return !line.startsWith('    at ');\n    });\n    if (!traces) return null;\n    if (traces[traces.length - 1].startsWith('SyntaxError:')) {\n      traces.pop();\n    }\n    return traces.join('\\n');\n  }\n  return null;\n}\nfunction isSyntaxError(error) {\n  return error instanceof SyntaxError || error.constructor.name === 'SyntaxError';\n}\nfunction resolveConfigExport(result, configFile, request) {\n  var _result;\n  if (result.default != null) {\n    result = result.default;\n  }\n  var exportedObjectType = typeof result;\n  if (typeof result === 'function') {\n    result = result(request);\n  }\n  if (result instanceof Promise) {\n    throw new (_Errors().ConfigError)(\"Config file \" + configFile + \" cannot return a Promise.\", 'INVALID_CONFIG');\n  }\n  if ((_result = result) !== null && _result !== void 0 && _result.expo) {\n    result = (0, _Serialize().serializeSkippingMods)(result.expo);\n  } else {\n    result = (0, _Serialize().serializeSkippingMods)(result);\n  }\n  return {\n    config: result,\n    exportedObjectType: exportedObjectType\n  };\n}","map":{"version":3,"sources":["../src/evalConfig.ts"],"names":["evalConfig","configFile","request","contents","result","code","filePath","transforms","error","location","extractLocationFromSyntaxError","codeFrameColumns","require","codeFrame","start","loc","highlightCode","message","importantStack","extractImportantStackFromNodeError","resolveConfigExport","line","lineNumber","column","columnNumber","isSyntaxError","traces","stack","split","filter","startsWith","length","pop","join","SyntaxError","constructor","name","default","exportedObjectType","Promise","ConfigError","expo","config"],"mappings":"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","sourcesContent":["import { readFileSync } from 'fs';\nimport requireString from 'require-from-string';\nimport { transform } from 'sucrase';\n\nimport { AppJSONConfig, ConfigContext, ExpoConfig } from './Config.types';\nimport { ConfigError } from './Errors';\nimport { serializeSkippingMods } from './Serialize';\n\ntype RawDynamicConfig = AppJSONConfig | Partial<ExpoConfig> | null;\n\nexport type DynamicConfigResults = { config: RawDynamicConfig; exportedObjectType: string };\n\n/**\n * Transpile and evaluate the dynamic config object.\n * This method is shared between the standard reading method in getConfig, and the headless script.\n *\n * @param options configFile path to the dynamic app.config.*, request to send to the dynamic config if it exports a function.\n * @returns the serialized and evaluated config along with the exported object type (object or function).\n */\nexport function evalConfig(\n  configFile: string,\n  request: ConfigContext | null\n): DynamicConfigResults {\n  const contents = readFileSync(configFile, 'utf8');\n  let result: any;\n  try {\n    const { code } = transform(contents, {\n      filePath: configFile,\n      transforms: ['typescript', 'imports'],\n    });\n\n    result = requireString(code, configFile);\n  } catch (error: any) {\n    const location = extractLocationFromSyntaxError(error);\n\n    // Apply a code frame preview to the error if possible, sucrase doesn't do this by default.\n    if (location) {\n      const { codeFrameColumns } = require('@babel/code-frame');\n      const codeFrame = codeFrameColumns(contents, { start: error.loc }, { highlightCode: true });\n      error.codeFrame = codeFrame;\n      error.message += `\\n${codeFrame}`;\n    } else {\n      const importantStack = extractImportantStackFromNodeError(error);\n\n      if (importantStack) {\n        error.message += `\\n${importantStack}`;\n      }\n    }\n    throw error;\n  }\n  return resolveConfigExport(result, configFile, request);\n}\n\nfunction extractLocationFromSyntaxError(\n  error: Error | any\n): { line: number; column?: number } | null {\n  // sucrase provides the `loc` object\n  if (error.loc) {\n    return error.loc;\n  }\n\n  // `SyntaxError`s provide the `lineNumber` and `columnNumber` properties\n  if ('lineNumber' in error && 'columnNumber' in error) {\n    return { line: error.lineNumber, column: error.columnNumber };\n  }\n\n  return null;\n}\n\n// These kinda errors often come from syntax errors in files that were imported by the main file.\n// An example is a module that includes an import statement.\nfunction extractImportantStackFromNodeError(error: any): string | null {\n  if (isSyntaxError(error)) {\n    const traces = error.stack?.split('\\n').filter((line) => !line.startsWith('    at '));\n    if (!traces) return null;\n\n    // Remove redundant line\n    if (traces[traces.length - 1].startsWith('SyntaxError:')) {\n      traces.pop();\n    }\n    return traces.join('\\n');\n  }\n  return null;\n}\n\nfunction isSyntaxError(error: any): error is SyntaxError {\n  return error instanceof SyntaxError || error.constructor.name === 'SyntaxError';\n}\n\n/**\n * - Resolve the exported contents of an Expo config (be it default or module.exports)\n * - Assert no promise exports\n * - Return config type\n * - Serialize config\n *\n * @param result\n * @param configFile\n * @param request\n */\nexport function resolveConfigExport(\n  result: any,\n  configFile: string,\n  request: ConfigContext | null\n) {\n  if (result.default != null) {\n    result = result.default;\n  }\n  const exportedObjectType = typeof result;\n  if (typeof result === 'function') {\n    result = result(request);\n  }\n\n  if (result instanceof Promise) {\n    throw new ConfigError(`Config file ${configFile} cannot return a Promise.`, 'INVALID_CONFIG');\n  }\n\n  // If the expo object exists, ignore all other values.\n  if (result?.expo) {\n    result = serializeSkippingMods(result.expo);\n  } else {\n    result = serializeSkippingMods(result);\n  }\n\n  return { config: result, exportedObjectType };\n}\n"]},"metadata":{},"sourceType":"script"}