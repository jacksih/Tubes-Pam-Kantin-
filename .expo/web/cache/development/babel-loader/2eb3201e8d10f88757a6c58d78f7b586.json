{"ast":null,"code":"\"use strict\";\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\nvar _wrapNativeSuper = require(\"@babel/runtime/helpers/wrapNativeSuper\");\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EmptyJsonFileError = void 0;\nvar JsonFileError = function (_Error) {\n  _inherits(JsonFileError, _Error);\n  var _super = _createSuper(JsonFileError);\n  function JsonFileError(message, cause, code, fileName) {\n    var _this;\n    _classCallCheck(this, JsonFileError);\n    var fullMessage = message;\n    if (fileName) {\n      fullMessage += \"\\n\" + (cause ? '├' : '└') + \"\\u2500 File: \" + fileName;\n    }\n    if (cause) {\n      fullMessage += \"\\n\\u2514\\u2500 Cause: \" + cause.name + \": \" + cause.message;\n    }\n    _this = _super.call(this, fullMessage);\n    _this.name = _this.constructor.name;\n    _this.cause = cause;\n    _this.code = code;\n    _this.fileName = fileName;\n    _this.isJsonFileError = true;\n    return _this;\n  }\n  return _createClass(JsonFileError);\n}(_wrapNativeSuper(Error));\nexports.default = JsonFileError;\nvar EmptyJsonFileError = function (_JsonFileError) {\n  _inherits(EmptyJsonFileError, _JsonFileError);\n  var _super2 = _createSuper(EmptyJsonFileError);\n  function EmptyJsonFileError(fileName) {\n    _classCallCheck(this, EmptyJsonFileError);\n    return _super2.call(this, \"Cannot parse an empty JSON string\", undefined, 'EJSONEMPTY', fileName);\n  }\n  return _createClass(EmptyJsonFileError);\n}(JsonFileError);\nexports.EmptyJsonFileError = EmptyJsonFileError;","map":{"version":3,"sources":["../src/JsonFileError.ts"],"names":[],"mappings":";;;;;;;;;;;;;;IAGqB,aAAc;EAAA;EAAA;EAMjC,uBAAY,OAAe,EAAE,KAAa,EAAE,IAAa,EAAE,QAAiB,EAAA;IAAA;IAAA;IAC1E,IAAI,WAAW,GAAG,OAAO;IACzB,IAAI,QAAQ,EAAE;MACZ,WAAW,YAAS,KAAK,GAAG,GAAG,GAAG,GAAG,sBAAW,QAAU;IAC3D;IACD,IAAI,KAAK,EAAE;MACT,WAAW,+BAAmB,KAAK,CAAC,IAAI,UAAK,KAAK,CAAC,OAAS;IAC7D;IACD,0BAAM,WAAW;IACjB,MAAK,IAAI,GAAG,MAAK,WAAW,CAAC,IAAI;IACjC,MAAK,KAAK,GAAG,KAAK;IAClB,MAAK,IAAI,GAAG,IAAI;IAChB,MAAK,QAAQ,GAAG,QAAQ;IACxB,MAAK,eAAe,GAAG,IAAI;IAAC;EAC9B;EAAC;AAAA,mBApBwC,KAAK;AAAhD,OAAA,CAAA,OAAA,GAAA,aAAA;AAqBC,IAEY,kBAAmB;EAAA;EAAA;EAC9B,4BAAY,QAAiB,EAAA;IAAA;IAAA,+DACgB,SAAS,EAAE,YAAY,EAAE,QAAQ;EAC9E;EAAC;AAAA,EAHqC,aAAa;AAArD,OAAA,CAAA,kBAAA,GAAA,kBAAA","sourcesContent":["/**\n * Note that instances of this class do NOT pass `instanceof JsonFileError`.\n */\nexport default class JsonFileError extends Error {\n  cause: Error | undefined;\n  code: string | undefined;\n  fileName: string | undefined;\n  isJsonFileError: true;\n\n  constructor(message: string, cause?: Error, code?: string, fileName?: string) {\n    let fullMessage = message;\n    if (fileName) {\n      fullMessage += `\\n${cause ? '├' : '└'}─ File: ${fileName}`;\n    }\n    if (cause) {\n      fullMessage += `\\n└─ Cause: ${cause.name}: ${cause.message}`;\n    }\n    super(fullMessage);\n    this.name = this.constructor.name;\n    this.cause = cause;\n    this.code = code;\n    this.fileName = fileName;\n    this.isJsonFileError = true;\n  }\n}\n\nexport class EmptyJsonFileError extends JsonFileError {\n  constructor(fileName?: string) {\n    super(`Cannot parse an empty JSON string`, undefined, 'EJSONEMPTY', fileName);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}