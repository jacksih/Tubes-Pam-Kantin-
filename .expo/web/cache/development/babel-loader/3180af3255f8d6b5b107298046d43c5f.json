{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ensureSlash = ensureSlash;\nexports.getEntryPoint = getEntryPoint;\nexports.getEntryPointWithExtensions = getEntryPointWithExtensions;\nexports.getFileWithExtensions = getFileWithExtensions;\nexports.getPossibleProjectRoot = getPossibleProjectRoot;\nexports.resolveEntryPoint = resolveEntryPoint;\nexports.resolveFromSilentWithExtensions = resolveFromSilentWithExtensions;\nfunction _fs() {\n  var data = _interopRequireDefault(require(\"fs\"));\n  _fs = function _fs() {\n    return data;\n  };\n  return data;\n}\nfunction _path() {\n  var data = _interopRequireDefault(require(\"path\"));\n  _path = function _path() {\n    return data;\n  };\n  return data;\n}\nfunction _resolveFrom() {\n  var data = _interopRequireDefault(require(\"resolve-from\"));\n  _resolveFrom = function _resolveFrom() {\n    return data;\n  };\n  return data;\n}\nfunction _Config() {\n  var data = require(\"../Config\");\n  _Config = function _Config() {\n    return data;\n  };\n  return data;\n}\nfunction _extensions() {\n  var data = require(\"./extensions\");\n  _extensions = function _extensions() {\n    return data;\n  };\n  return data;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction ensureSlash(inputPath, needsSlash) {\n  var hasSlash = inputPath.endsWith('/');\n  if (hasSlash && !needsSlash) {\n    return inputPath.substr(0, inputPath.length - 1);\n  } else if (!hasSlash && needsSlash) {\n    return inputPath + \"/\";\n  } else {\n    return inputPath;\n  }\n}\nfunction getPossibleProjectRoot() {\n  return _fs().default.realpathSync(process.cwd());\n}\nvar nativePlatforms = ['ios', 'android'];\nfunction resolveEntryPoint(projectRoot, _ref) {\n  var platform = _ref.platform,\n    projectConfig = _ref.projectConfig;\n  var platforms = nativePlatforms.includes(platform) ? [platform, 'native'] : [platform];\n  return getEntryPoint(projectRoot, ['./index'], platforms, projectConfig);\n}\nfunction getEntryPoint(projectRoot, entryFiles, platforms, projectConfig) {\n  var extensions = (0, _extensions().getBareExtensions)(platforms);\n  return getEntryPointWithExtensions(projectRoot, entryFiles, extensions, projectConfig);\n}\nfunction getEntryPointWithExtensions(projectRoot, entryFiles, extensions, projectConfig) {\n  var _ref2 = projectConfig !== null && projectConfig !== void 0 ? projectConfig : (0, _Config().getConfig)(projectRoot, {\n      skipSDKVersionRequirement: true\n    }),\n    exp = _ref2.exp,\n    pkg = _ref2.pkg;\n  if (exp && exp.entryPoint && typeof exp.entryPoint === 'string') {\n    var entry = getFileWithExtensions(projectRoot, exp.entryPoint, extensions);\n    if (!entry) {\n      entry = resolveFromSilentWithExtensions(projectRoot, exp.entryPoint, extensions);\n      if (!entry) {\n        return exp.entryPoint;\n      }\n    }\n    return entry;\n  } else if (pkg) {\n    var main = pkg.main;\n    if (main && typeof main === 'string') {\n      var _entry = getFileWithExtensions(projectRoot, main, extensions);\n      if (!_entry) {\n        _entry = resolveFromSilentWithExtensions(projectRoot, main, extensions);\n        if (!_entry) throw new Error(\"Cannot resolve entry file: The `main` field defined in your `package.json` points to a non-existent path.\");\n      }\n      return _entry;\n    }\n  }\n  for (var fileName of entryFiles) {\n    var _entry2 = resolveFromSilentWithExtensions(projectRoot, fileName, extensions);\n    if (_entry2) return _entry2;\n  }\n  try {\n    return (0, _resolveFrom().default)(projectRoot, 'expo/AppEntry');\n  } catch (_unused) {\n    throw new Error(\"The project entry file could not be resolved. Please either define it in the `package.json` (main), `app.json` (expo.entryPoint), create an `index.js`, or install the `expo` package.\");\n  }\n}\nfunction resolveFromSilentWithExtensions(fromDirectory, moduleId, extensions) {\n  for (var extension of extensions) {\n    var modulePath = _resolveFrom().default.silent(fromDirectory, moduleId + \".\" + extension);\n    if (modulePath && modulePath.endsWith(extension)) {\n      return modulePath;\n    }\n  }\n  return _resolveFrom().default.silent(fromDirectory, moduleId) || null;\n}\nfunction getFileWithExtensions(fromDirectory, moduleId, extensions) {\n  var modulePath = _path().default.join(fromDirectory, moduleId);\n  if (_fs().default.existsSync(modulePath)) {\n    return modulePath;\n  }\n  for (var extension of extensions) {\n    var _modulePath = _path().default.join(fromDirectory, moduleId + \".\" + extension);\n    if (_fs().default.existsSync(_modulePath)) {\n      return _modulePath;\n    }\n  }\n  return null;\n}","map":{"version":3,"sources":["../../src/paths/paths.ts"],"names":["ensureSlash","inputPath","needsSlash","hasSlash","endsWith","substr","length","getPossibleProjectRoot","fs","realpathSync","process","cwd","nativePlatforms","resolveEntryPoint","projectRoot","platform","projectConfig","platforms","includes","getEntryPoint","entryFiles","extensions","getEntryPointWithExtensions","exp","pkg","skipSDKVersionRequirement","entryPoint","entry","getFileWithExtensions","resolveFromSilentWithExtensions","main","Error","fileName","fromDirectory","moduleId","extension","modulePath","resolveFrom","silent","path","join","existsSync"],"mappings":"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","sourcesContent":["import fs from 'fs';\nimport path from 'path';\nimport resolveFrom from 'resolve-from';\n\nimport { getConfig } from '../Config';\nimport { ProjectConfig } from '../Config.types';\nimport { getBareExtensions } from './extensions';\n\n// https://github.com/facebook/create-react-app/blob/9750738cce89a967cc71f28390daf5d4311b193c/packages/react-scripts/config/paths.js#L22\nexport function ensureSlash(inputPath: string, needsSlash: boolean): string {\n  const hasSlash = inputPath.endsWith('/');\n  if (hasSlash && !needsSlash) {\n    return inputPath.substr(0, inputPath.length - 1);\n  } else if (!hasSlash && needsSlash) {\n    return `${inputPath}/`;\n  } else {\n    return inputPath;\n  }\n}\n\nexport function getPossibleProjectRoot(): string {\n  return fs.realpathSync(process.cwd());\n}\n\nconst nativePlatforms = ['ios', 'android'];\n\nexport function resolveEntryPoint(\n  projectRoot: string,\n  { platform, projectConfig }: { platform: string; projectConfig?: ProjectConfig }\n) {\n  const platforms = nativePlatforms.includes(platform) ? [platform, 'native'] : [platform];\n  return getEntryPoint(projectRoot, ['./index'], platforms, projectConfig);\n}\n\nexport function getEntryPoint(\n  projectRoot: string,\n  entryFiles: string[],\n  platforms: string[],\n  projectConfig?: ProjectConfig\n): string | null {\n  const extensions = getBareExtensions(platforms);\n  return getEntryPointWithExtensions(projectRoot, entryFiles, extensions, projectConfig);\n}\n\n// Used to resolve the main entry file for a project.\nexport function getEntryPointWithExtensions(\n  projectRoot: string,\n  entryFiles: string[],\n  extensions: string[],\n  projectConfig?: ProjectConfig\n): string {\n  const { exp, pkg } = projectConfig ?? getConfig(projectRoot, { skipSDKVersionRequirement: true });\n\n  // This will first look in the `app.json`s `expo.entryPoint` field for a potential main file.\n  // We check the Expo config first in case you want your project to start differently with Expo then in a standalone environment.\n  if (exp && exp.entryPoint && typeof exp.entryPoint === 'string') {\n    // If the field exists then we want to test it against every one of the supplied extensions\n    // to ensure the bundler resolves the same way.\n    let entry = getFileWithExtensions(projectRoot, exp.entryPoint, extensions);\n    if (!entry) {\n      // Allow for paths like: `{ \"main\": \"expo/AppEntry\" }`\n      entry = resolveFromSilentWithExtensions(projectRoot, exp.entryPoint, extensions);\n\n      // If it doesn't resolve then just return the entryPoint as-is. This makes\n      // it possible for people who have an unconventional setup (eg: multiple\n      // apps in monorepo with metro at root) to customize entry point without\n      // us imposing our assumptions.\n      if (!entry) {\n        return exp.entryPoint;\n      }\n    }\n    return entry;\n  } else if (pkg) {\n    // If the config doesn't define a custom entry then we want to look at the `package.json`s `main` field, and try again.\n    const { main } = pkg;\n    if (main && typeof main === 'string') {\n      // Testing the main field against all of the provided extensions - for legacy reasons we can't use node module resolution as the package.json allows you to pass in a file without a relative path and expect it as a relative path.\n      let entry = getFileWithExtensions(projectRoot, main, extensions);\n      if (!entry) {\n        // Allow for paths like: `{ \"main\": \"expo/AppEntry\" }`\n        entry = resolveFromSilentWithExtensions(projectRoot, main, extensions);\n        if (!entry)\n          throw new Error(\n            `Cannot resolve entry file: The \\`main\\` field defined in your \\`package.json\\` points to a non-existent path.`\n          );\n      }\n      return entry;\n    }\n  }\n\n  // Now we will start looking for a default entry point using the provided `entryFiles` argument.\n  // This will add support for create-react-app (src/index.js) and react-native-cli (index.js) which don't define a main.\n  for (const fileName of entryFiles) {\n    const entry = resolveFromSilentWithExtensions(projectRoot, fileName, extensions);\n    if (entry) return entry;\n  }\n\n  try {\n    // If none of the default files exist then we will attempt to use the main Expo entry point.\n    // This requires `expo` to be installed in the project to work as it will use `node_module/expo/AppEntry.js`\n    // Doing this enables us to create a bare minimum Expo project.\n\n    // TODO(Bacon): We may want to do a check against `./App` and `expo` in the `package.json` `dependencies` as we can more accurately ensure that the project is expo-min without needing the modules installed.\n    return resolveFrom(projectRoot, 'expo/AppEntry');\n  } catch {\n    throw new Error(\n      `The project entry file could not be resolved. Please either define it in the \\`package.json\\` (main), \\`app.json\\` (expo.entryPoint), create an \\`index.js\\`, or install the \\`expo\\` package.`\n    );\n  }\n}\n\n// Resolve from but with the ability to resolve like a bundler\nexport function resolveFromSilentWithExtensions(\n  fromDirectory: string,\n  moduleId: string,\n  extensions: string[]\n): string | null {\n  for (const extension of extensions) {\n    const modulePath = resolveFrom.silent(fromDirectory, `${moduleId}.${extension}`);\n    if (modulePath && modulePath.endsWith(extension)) {\n      return modulePath;\n    }\n  }\n  return resolveFrom.silent(fromDirectory, moduleId) || null;\n}\n\n// Statically attempt to resolve a module but with the ability to resolve like a bundler.\n// This won't use node module resolution.\nexport function getFileWithExtensions(\n  fromDirectory: string,\n  moduleId: string,\n  extensions: string[]\n): string | null {\n  const modulePath = path.join(fromDirectory, moduleId);\n  if (fs.existsSync(modulePath)) {\n    return modulePath;\n  }\n  for (const extension of extensions) {\n    const modulePath = path.join(fromDirectory, `${moduleId}.${extension}`);\n    if (fs.existsSync(modulePath)) {\n      return modulePath;\n    }\n  }\n  return null;\n}\n"]},"metadata":{},"sourceType":"script"}